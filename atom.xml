<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2019-11-30T13:30:13.681Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io//atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io//images/avatar.png</logo>
    <icon>https://zy080080.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[计算机如何识别中文字符]]></title>
        <id>https://zy080080.github.io//post/7045yjWiy</id>
        <link href="https://zy080080.github.io//post/7045yjWiy">
        </link>
        <updated>2019-11-30T15:25:35.000Z</updated>
        <summary type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用字节输入流将中文字符打印到控制台时往往无法识别，而使用字节流复制文件却可以完美显示，计算机是如何识别中文字符的呢？</p>
<!-- more -->
<pre><code>String str = &quot;中文输入&quot;;
byte[] by = str.getBytes();
System.out.println(by.toString());

//输出打印结果为[-28, -72, -83, -26, -106, -121, -24, -66, -109, -27, -123, -91]
</code></pre>
<p>遇到负数时，自动与下一个数拼接，得到中文字符。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流的关闭方式]]></title>
        <id>https://zy080080.github.io//post/RtEn3DuwS</id>
        <link href="https://zy080080.github.io//post/RtEn3DuwS">
        </link>
        <updated>2019-11-15T13:13:12.000Z</updated>
        <summary type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
]]></summary>
        <content type="html"><![CDATA[<p> 所有的流都应该在使用完毕后关闭。如果不关闭，会占用资源。</p>
<!-- more -->
<h2 id="在try中关闭">在try中关闭</h2>
<p> 有隐患。如果文件不存在或者在读取时出现异常，关闭流的方法不会被执行。 <strong>不推荐使用</strong></p>
<h2 id="在finally中关闭">在finally中关闭</h2>
<p> 这是标准的关闭流的方式。<br>
 在关闭时，需要进行一次try catch处理。<br>
 在写不重要的代码时可以采用try中关闭，不麻烦。</p>
<pre><code>try {
    FileOutputStream fos = new FileOutputStream(f);
    fos.write(data1);
    fos.write(data2);
    fos.write(data4);
    fos.write(data3);
    //fos.close();  
} catch (IOException e) {
    e.printStackTrace();
}finally {
    try {
        fos.close();
    }catch(IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2 id="使用try的方式">使用try()的方式</h2>
<p> 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭。<br>
 这种编写代码的方式叫做 <mark>try-with-resources</mark>， 这是从JDK7开始支持的技术<br>
 所有的流，都实现了一个接口叫做 <mark>AutoCloseable</mark>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>public static void main(String[] args) {
File f = new File(&quot;d:/lol.txt&quot;);

    //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
    try (FileInputStream fis = new FileInputStream(f)) {
        byte[] all = new byte[(int) f.length()];
        fis.read(all);
        for (byte b : all) {
            System.out.println(b);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异常 Exception]]></title>
        <id>https://zy080080.github.io//post/jfUUCCexq</id>
        <link href="https://zy080080.github.io//post/jfUUCCexq">
        </link>
        <updated>2019-11-12T15:24:40.000Z</updated>
        <summary type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
]]></summary>
        <content type="html"><![CDATA[<p>异常分为运行时异常（可查异常）和非运行时异常（不可查异常），他们的主要区别是……</p>
<!-- more -->
<h2 id="可查异常-checkedexception">可查异常 CheckedException</h2>
<p>可查异常是必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException。</p>
<p>如果不处理，<mark><strong>编译器就不让你通过</strong></mark></p>
<h2 id="运行时异常-runtimeexception">运行时异常 RuntimeException</h2>
<p>常见运行时异常（不可查异常）：</p>
<ul>
<li>除数不能为0异常 ArithmeticException</li>
<li>下标越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<p>在编写代码的时候，依然可以使用try cathc throws进行处理，与可查异常（非运行时异常）不同之处在于：</p>
<ul>
<li>即使不进行try catch，也 <mark><strong>不会有编译错误</strong></mark></li>
</ul>
<p>Java之所以设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟。</p>
<h2 id="错误-error">错误 Error</h2>
<p>指的是系统级别的异常，通常是内存用光了。</p>
<blockquote>
<p>总结：</p>
<p>运行时异常与非运行时异常的最大区别是，运行时异常（不可查异常）不需要进行显式的捕捉，编译器会让你通过。</p>
<p>而非运行时异常（可查异常）需要进行显式的捕捉，不然编译器不会让你通过。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ラズベリーパイ 4Bが起動しない時の対応法]]></title>
        <id>https://zy080080.github.io//post/1tSysQNzy</id>
        <link href="https://zy080080.github.io//post/1tSysQNzy">
        </link>
        <updated>2019-10-06T03:00:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a></p>
<!-- more -->
<p>ラズベリーパイを手に入れてからすぐにNOOBSでインストールしてみたが、起動できませんでした。<br>
そしてシステムを直接SDカードにインストールするのも試しましたが、同じく赤いLEDだけが点灯して、起動が失敗しました。</p>
<p>まだラズパイ４Bに関してネット上に乗っている情報が少ないですが、公式Webページから対応法が見つかりました。</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p>やっぱり英語は大切ですね。。。。</p>
<p>ちなみに、SDカードをカードリーダに入れてUSBとしてラズパイに差し込んだ人もいたらしいですが、ちゃんと裏面にセットすれば問題ないはずです。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A solution of unable to boot up Raspberry Pi 4B]]></title>
        <id>https://zy080080.github.io//post/dgAVKMhPS</id>
        <link href="https://zy080080.github.io//post/dgAVKMhPS">
        </link>
        <updated>2019-10-05T21:26:46.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/pE2JY0ig0/">解决无法启动树莓派4B的问题</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> I received my new Raspberry Pi yesterday. I tried to boot up the Pi in two ways, but it couldn't be boot.<br>
 At last, I found the solution on its homepage:</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决无法启动树莓派4B的问题]]></title>
        <id>https://zy080080.github.io//post/pE2JY0ig0</id>
        <link href="https://zy080080.github.io//post/pE2JY0ig0">
        </link>
        <updated>2019-10-05T16:34:08.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://zy080080.github.io/post/dgAVKMhPS/">A solution of unable to boot up Raspberry Pi 4B</a><br>
<a href="https://zy080080.github.io/post/1tSysQNzy/">ラズベリーパイ 4Bが起動しない時の対応法</a></p>
<!-- more -->
<p> 昨天从日亚买的树莓派4B到货了，但是按网上说的无论是用NOOBS还是直接装系统都无法正常启动，一直处于红灯常亮状态。<br>
 找了半天相关消息都比较少，直到从官网看到：</p>
<blockquote>
<p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a><br>
If your Raspberry Pi 4 will not boot, it is possible that the SPI EEPROM has become corrupted.<br>
To check, remove the SD card, disconnect the device from power, then reconnect it. If the green LED does not flash, you will need to reprogram the EEPROM:</p>
<ul>
<li>Download the bootloader</li>
<li>Extract it to an empty FAT-formatted SD card and insert it into your Raspberry Pi 4</li>
<li>Connect the power and wait for the green LED to flash quickly</li>
</ul>
<p>Notes:</p>
<ul>
<li>The updated bootloader improves compatibility with HATs by changing the behaviour of HALT to keep the 3V3 pin powered (view the full bootloader release notes)</li>
<li>The previous bootloader remains available for download</li>
</ul>
</blockquote>
<p> 按照这个将下载的bootloader装进SD卡启动直到绿灯闪烁后，再次装NOOBS或者Raspbian系统，问题才得以解决。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Does Java pass by reference or pass by value?]]></title>
        <id>https://zy080080.github.io//post/fFi1CAqNV</id>
        <link href="https://zy080080.github.io//post/fFi1CAqNV">
        </link>
        <updated>2019-09-15T16:46:51.000Z</updated>
        <summary type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Source：<a href="https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html">https://www.javaworld.com/article/2077424/learn-java-does-java-pass-by-reference-or-pass-by-value.html</a></p>
<!-- more -->
<p><a href="https://zy080080.github.io/post/UYqd_tZ7B/">点此查看相关中文文章</a></p>
<h2 id="q-learn-java-if-java-uses-the-pass-by-reference-why-wont-a-swap-function-work">Q: Learn Java: If Java uses the pass-by reference, why won't a swap function work?</h2>
<p>A: Java does manipulate objects by reference, and all object variables are references. However, Java doesn't pass method arguments by reference; it passes them by value.</p>
<p>Take the badSwap() method for example:</p>
<pre><code>public void badSwap(int var1, int var2)
{
 int temp = var1;
 var1 = var2;
 var2 = temp;
}
</code></pre>
<p>When badSwap() returns, the variables passed as arguments will still hold their original values. The method will also fail if we change the arguments type from int to Object, since Java passes object references by value as well. Now, here is where it gets tricky:</p>
<pre><code>public void tricky(Point arg1, Point arg2)
{
 arg1.x = 100;
 arg1.y = 100;
 Point temp = arg1;
 arg1 = arg2;
 arg2 = temp;
}
public static void main(String [] args)
{
 Point pnt1 = new Point(0,0);
 Point pnt2 = new Point(0,0);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y: &quot; +pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);
 System.out.println(&quot; &quot;);
 tricky(pnt1,pnt2);
 System.out.println(&quot;X: &quot; + pnt1.x + &quot; Y:&quot; + pnt1.y); 
 System.out.println(&quot;X: &quot; + pnt2.x + &quot; Y: &quot; +pnt2.y);  
}
</code></pre>
<p>If we execute this main() method, we see the following output:</p>
<pre><code>X: 0 Y: 0
X: 0 Y: 0
X: 100 Y: 100
X: 0 Y: 0
</code></pre>
<p>The method successfully alters the value of pnt1, even though it is passed by value; however, a swap of pnt1 and pnt2 fails! This is the major source of confusion. In the main() method, pnt1 and pnt2 are nothing more than object references. When you pass pnt1 and pnt2 to the tricky() method, Java passes the references by value just like any other parameter. This means the references passed to the method are actually copies of the original references. Figure 1 below shows two references pointing to the same object after Java passes an object to a method.</p>
<figure data-type="image" tabindex="1"><img src="https://images.techhive.com/images/idge/imported/article/jvw/2000/05/03-qa-0512-pass1-100158781-orig.gif" alt="Figure 1. After being passed to a method, an object will have at least two references"></figure>
<p>Java copies and passes the reference by value, not the object. Thus, method manipulation will alter the objects, since the references point to the original objects. But since the references are copies, swaps will fail. As Figure 2 illustrates, the method references swap, but not the original references. Unfortunately, after a method call, you are left with only the unswapped original references. For a swap to succeed outside of the method call, we need to swap the original references, not the copies.</p>
<p>O'Reilly's Java in a Nutshell by David Flanagan (see Resources) puts it best: &quot;Java manipulates objects 'by reference,' but it passes object references to methods 'by value.'&quot; As a result, you cannot write a standard swap method to swap objects.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编语言笔记（第三章）]]></title>
        <id>https://zy080080.github.io//post/lwMS0nfZZ</id>
        <link href="https://zy080080.github.io//post/lwMS0nfZZ">
        </link>
        <updated>2019-09-13T03:39:41.000Z</updated>
        <summary type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
]]></summary>
        <content type="html"><![CDATA[<p>汇编语言（第三版） 王爽著 清华大学出版社</p>
<!-- more -->
<h1 id="第三章-寄存器内存访问">第三章 寄存器（内存访问）</h1>
<h2 id="31-内存中字的存储">3.1 内存中字的存储</h2>
<p> CPU中用16位寄存器来存储一个字，高8位存放高位字节，低8位存放低位字节，在内存中储存时，由于内存单元是字节单元（一个字节存放一个单元），则一个字要用两个地址连续的内存单元来存放。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>20H</td>
</tr>
<tr>
<td>1</td>
<td>4EH</td>
</tr>
<tr>
<td>2</td>
<td>12H</td>
</tr>
<tr>
<td>4</td>
<td>00H</td>
</tr>
<tr>
<td>5</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
</tr>
</tbody>
</table>
<p> 如表格，我们用0，1两个内存单元存放数据20000（4E20H）。4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中。这两个内存单元可以看做一个起始地址为0的字单元（存放一个字的内存单元，由0、1两个字节单元组成）。数据18（0012H）同理。</p>
<h3 id="我们将起始地址为n的字单元简称为n地址字单元-比如一个字单元有2-3两个内存单元组成则这个字单元的起始地址为2我们可以说这是2地址字单元"> <strong>我们将起始地址为N的字单元简称为N地址字单元。比如一个字单元有2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元</strong></h3>
<h2 id="32-ds和adress">3.2 DS和[adress]</h2>
<p> CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址和偏移地址组成。8086CPU中有个DS寄存器，通常用来存放要访问数据的段地址。比如我们要读取10000H单元的内容，可以用如下的程序段进行：</p>
<p>mov bx,1000H<br>
mov ds,bx<br>
mov al,[0]</p>
<p> 上面的三条指令将10000H（1000：0）中的数据读到al中<br>
 mov指令可以将一个内存单元中的内容送入一个寄存器中，内存单元需要用内存单元的地址来指明。格式为 mov 寄存器名，内存单元地址。<br>
 “[···]“表示一个内存单元，其中的内容表示内存单元的偏移地址。而段地址存储在DS寄存器中。<br>
 DS是一个段寄存器，8086CPU不支持将数据直接从入段寄存器的操作。 mov ds，1000H <strong>是非法的</strong></p>
<p> 数据还可以从寄存器送入内存单元，如：</p>
<pre><code>mov bx,1000H
mov ds,bx 
mov [0],al
</code></pre>
<h2 id="33-字的传送">3.3 字的传送</h2>
<p> 8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，即一次性传送一个字。</p>
<pre><code>mov ax,1000H
mov ds,bx
mov ax,[0] //1000:0 处的字形数据送入ax
mov [0],cx //cx中的16位数据送到 1000:0 处
</code></pre>
<blockquote>
<p>注意：传送到ax，bx，cx的是字形数据，传送到al，ah，bl，bh的是字节型数据。</p>
</blockquote>
<h2 id="34-mov-add-sub指令">3.4 mov、add、sub指令</h2>
<p> 到现在，我们知道mov指令可以有以下几种形式：</p>
<pre><code>mov ax,8    //寄存器，数据
mov ax,bx   //寄存器，寄存器
mov ax,[0]  //寄存器，内存单元
mov [0],ax  //内存单元，寄存器
mov ds,ax   //段寄存器，寄存器
</code></pre>
<p> 利用Debug验证后，下列指令也可成立：</p>
<pre><code>mov ax,dx   //寄存器，段寄存器
mov [0],cs  //内存单元，段寄存器
mov ds,[0]  //段寄存器，内存单元
</code></pre>
<p> add和sub指令同mov一样，都有两个操作对象，它们也可以有以下几种形式：</p>
<pre><code>add ax,8    //寄存器，数据
add ax,bx   //寄存器，寄存器
add ax,[0]  //寄存器，内存单元
add [0],ax  //内存单元，寄存器
sub ax,9    //寄存器，数据
sub sx,bx   //寄存器，寄存器
sub ax,[0]  //寄存器，内存单元
sub [0],ax  //内存单元，寄存器
</code></pre>
<p> <mark>但他们无法对段寄存器操作</mark></p>
<h2 id="35-数据段">3.5 数据段</h2>
<p> 对于8086机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64KB)、地址连续、起始地址为16的倍数的内存单元当做专门存储数据的内存空间，从而定义了一个数据段。<br>
 比如讲 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前3个单元的数据，代码如下。</p>
<pre><code>mov ax,123BH    
mov ds,ax       //将123BH送入ds中，作为数据段的段地址
mov al,0        //用al存放累加结果
add al,[0]      //将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]      //将数据段第二个单元（偏移地址为0）中的数值加到al中
add al,[2]      //将数据段第三个单元（偏移地址为0）中的数值加到al中
</code></pre>
<h2 id="36-桟">3.6 桟</h2>
<p> 桟是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p>
<table>
<thead>
<tr>
<th style="text-align:center">桟</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">...</td>
</tr>
<tr>
<td style="text-align:center">四单个数据</td>
</tr>
<tr>
<td style="text-align:center">第二个数据</td>
</tr>
<tr>
<td style="text-align:center">第一个数据</td>
</tr>
</tbody>
</table>
<p> 入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入桟，需要出栈时，由最先被从桟中取出。桟的这种操作规则被称为：LIFO（Last In First Out）。</p>
<h2 id="37-cpu提供的桟机制">3.7 CPU提供的桟机制</h2>
<p> 8086CPU提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。</p>
<pre><code>push ax //将寄存器ax中的数据送入桟中
pop ax  //从栈顶取出数据送入ax
</code></pre>
<p> <mark>8086CPU的入栈和出栈操作都是以<strong>字</strong>为单位进行的</mark></p>
<p> 8086CPU中，有两个寄存器，段寄存器 SS 和寄存器 SP，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。任意时刻， SS:SP 指向<strong>栈顶元素</strong>。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>
<p> push ax的执行，由以下两步组成。</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</li>
</ol>
<p> 8086CPU对push指令的执行过程：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000E</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑栈中原本存在数据0123H，此时SS:SP指向1000EH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td></td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第一步：SP=SP-2，SS:SP指向1000CH。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
<th>SS:SP位置</th>
<th>当前状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SS=1000</td>
</tr>
<tr>
<td>...</td>
<td></td>
<td></td>
<td>SP=000C</td>
</tr>
<tr>
<td>1000B</td>
<td></td>
<td></td>
<td>AX=2266</td>
</tr>
<tr>
<td>1000C</td>
<td>66</td>
<td>←SS:SP</td>
<td></td>
</tr>
<tr>
<td>1000D</td>
<td>22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000E</td>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000F</td>
<td>01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p> ↑CPU执行push，第二步：将AX中的数据送入SS:SP指向的内存单元处。</p>
<p> pop ax 的执行过程：</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中。</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p>注意：出栈后，原本SS:SP指向的单元内的内容依然存在，但是它已经不在栈中。当再次执行push等入栈指令后，会被新数据覆盖。</p>
<h2 id="38-栈顶超界的问题">3.8 栈顶超界的问题</h2>
<p> 8086CPU不保证我对栈的操作不会越界。也就是说，8086CPU只知道栈顶在何处（SS:SP），而不知道我们安排的栈空间有多大。这好像CPU只知道当前要执行的指令在哪里（CS:IP），而不知道要执行的指令有多少。从这两点我们可以看出8086CPU的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。<br>
 我们在编程时要自己操心栈顶超界的问题。</p>
<h2 id="39-push-pop指令">3.9 push、pop指令</h2>
<p> push和pop指令的格式可以是如下形式：</p>
<pre><code>push 寄存器     //将一个寄存器的数据入栈
pop 寄存器      //出栈，用一个寄存器接收出栈的数据
</code></pre>
<p> 当然也可以是如下形式：</p>
<pre><code>push 段寄存器   //将一个段寄存器的数据入栈
pop 段寄存器    //出栈，用一个段寄存器接收出栈的数据
</code></pre>
<p> push和pop也可以在内存单元和内存单元之间传送数据：</p>
<pre><code>push 内存单元   //将一个内存字单元处的字入栈（**注意：栈操作都是以字为单位的**）
pop 内存单元    //出栈，用一个内存字单元接收出栈的数据
</code></pre>
<p> 比如：</p>
<pre><code>mov ax,1000H    
mov ds,ax       //内存单元的段地址要放在DS中
push [0]        //将1000：0处的字压入栈中
pop [2]         //出栈，出栈的数据送入1000：2处
</code></pre>
<p> 栈为空的情况：<br>
将10000~1000F当做栈，初始状态为空</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">内容</th>
<th>SS:SP指向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10000</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">...</td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000C</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000D</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000E</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">1000F</td>
<td style="text-align:center">空</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">10010</td>
<td style="text-align:center">(其他内容)</td>
<td>←SS:SP</td>
</tr>
</tbody>
</table>
<p> 执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。<br>
 执行pop时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP。</p>
<p> 栈顶的变化范围：0~FFFFH。</p>
<h2 id="310-栈段">3.10 栈段</h2>
<p> 我们可以将长度为N（N&lt;=64KB）的一组地址连续、起始地址为16的倍数的内存单元当做栈来使用。</p>
<p> 如果将10000H~1FFFFH这段空间当做栈段，初始状态栈是空的，此时SS=1000H，<strong>SP=0</strong>。（任意时刻，SS:SP指向栈顶元素，当栈为空时，也就不存在栈顶元素，所以SS:SP只能指向站的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H）</p>
<h3 id="实验2">实验2：</h3>
<p> 当用T执行mov ss，ax（任何修改SS的指令）的时候，它的下一条指令也会被紧接着执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[StringBuffer作为参数传递问题]]></title>
        <id>https://zy080080.github.io//post/SbZ2wCsCd</id>
        <link href="https://zy080080.github.io//post/SbZ2wCsCd">
        </link>
        <updated>2019-09-12T09:12:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code>public class StringBufferTest {
    public static void main(String[] args) {
	    String s1 = &quot;hello&quot;;
		String s2 = &quot;world&quot;;
    	System.out.println(s1 + &quot;---&quot; + s2);// hello---world
	    change(s1, s2);
		System.out.println(s1 + &quot;---&quot; + s2);// hello---world 

    	StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
	    StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
    	System.out.println(sb1 + &quot;---&quot; + sb2);// hello---world
		change(sb1, sb2);
		System.out.println(sb1 + &quot;---&quot; + sb2);// hello---worldworld
	}

	public static void change(StringBuffer sb1, StringBuffer sb2) {
		sb1 = sb2;//引用的东西变了而已，main中的sb1引用没变
		sb2.append(sb1);
	}

    public static void change(String s1, String s2) {
	    s1 = s2;
	    s2 = s1 + s2;
    }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java到底是值传递还是引用传递？]]></title>
        <id>https://zy080080.github.io//post/UYqd_tZ7B</id>
        <link href="https://zy080080.github.io//post/UYqd_tZ7B">
        </link>
        <updated>2019-09-12T05:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>原文作者：Intopass<br>
链接：<a href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a><br>
来源：知乎</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文作者：Intopass<br>
链接：<a href="https://www.zhihu.com/question/31203609/answer/50992895">https://www.zhihu.com/question/31203609/answer/50992895</a><br>
来源：知乎</p>
 <!-- more --> 
<p><a href="https://zy080080.github.io/post/fFi1CAqNV/">Click here to read a related article in English</a></p>
<p> 首先，不要纠结于 Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其实本质上是传值”这种并不能解决问题无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还是传引用。这就好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。</p>
<h2 id="一搞清楚-基本类型-和-引用类型的不同之处">一：搞清楚 基本类型 和 引用类型的不同之处</h2>
<pre><code>int sun = 10;
String str = &quot;Hello&quot;;
</code></pre>
<p><img src="https://pic3.zhimg.com/80/166032bc90958c21604110441ad03f45_hd.jpg" alt=""><br>
 如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为&quot;引用&quot;，引用指向实际对象，实际对象中保存着内容。</p>
<h2 id="二搞清楚赋值运算符的作用">二：搞清楚赋值运算符（=）的作用</h2>
<pre><code>num = 20;
str = &quot;java&quot;;
</code></pre>
<p><img src="https://pic4.zhimg.com/80/287c0efbb179638cf4cf27cbfdf3e746_hd.jpg" alt=""><br>
 对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>
 对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<mark><strong>但是原来的对象不会被改变（重要）</strong></mark>。如上图所示，&quot;hello&quot; 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）</p>
<h2 id="三调用方法时发生了什么参数传递基本上就是赋值操作">三：调用方法时发生了什么？<strong>参数传递基本上就是赋值操作</strong>。</h2>
<pre><code>第一个例子：基本类型
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变

第二个例子：没有提供改变自身方法的引用类型
void foo(String text) {
    text = &quot;windows&quot;;
}
foo(str); // str 也没有被改变

第三个例子：提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder(&quot;iphone&quot;);
void foo(StringBuilder builder) {
    builder.append(&quot;4&quot;);
}
foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。

第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder(&quot;iphone&quot;);
void foo(StringBuilder builder) {
    builder = new StringBuilder(&quot;ipad&quot;);
}
foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。
</code></pre>
<p> 重点理解为什么，第三个例子和第四个例子结果不同？</p>
<h3 id="下面是第三个例子的图解">下面是第三个例子的图解：</h3>
<figure data-type="image" tabindex="1"><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt=""></figure>
<p> builder.append(&quot;4&quot;)之后</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/ff2ede9c6c55568d42425561f25a0fd7_hd.jpg" alt=""></figure>
<h3 id="下面是第四个例子的图解">下面是第四个例子的图解：</h3>
<figure data-type="image" tabindex="3"><img src="https://pic2.zhimg.com/80/d8b82e07ea21375ca6b300f9162aa95f_hd.jpg" alt=""></figure>
<p> builder = new StringBuilder(&quot;ipad&quot;); 之后</p>
<figure data-type="image" tabindex="4"><img src="https://pic4.zhimg.com/80/46fa5f10cc135a3ca087dae35a5211bd_hd.jpg" alt=""></figure>
<hr>
<p>2018年1月31日添加部分内容：</p>
<h2 id="从局部变量方法参数开始讲起">从局部变量/方法参数开始讲起：</h2>
<p> 局部变量和方法参数在jvm中的储存方法是相同的，都是在栈上开辟空间来储存的，随着进入方法开辟，退出方法回收。以32位JVM为例，boolean/byte/short/char/int/float以及引用都是分配4字节空间，long/double分配8字节空间。对于每个方法来说，最多占用多少空间是一定的，这在编译时就可以计算好。</p>
<p> 我们都知道JVM内存模型中有，stack和heap的存在，但是更准确的说，是每个线程都分配一个独享的stack，所有线程共享一个heap。对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更遑论修改。</p>
<p> 当我们在方法中声明一个 int i = 0，或者 Object obj = null 时，仅仅涉及stack，不影响到heap，当我们 new Object() 时，会在heap中开辟一段内存并初始化Object对象。当我们将这个对象赋予obj变量时，仅仅是stack中代表obj的那4个字节变更为这个对象的地址。</p>
<h2 id="数组类型引用和对象">数组类型引用和对象：</h2>
<p> 当我们声明一个数组时，如int[] arr = new int[10]，因为数组也是对象，arr实际上是引用，stack上仅仅占用4字节空间，new int[10]会在heap中开辟一个数组对象，然后arr指向它。</p>
<p> 当我们声明一个二维数组时，如 int[][] arr2 = new int[2][4]，arr2同样仅在stack中占用4个字节，会在内存中开辟一个长度为2的，类型为int[]的数组，然后arr2指向这个数组。这个数组内部有两个引用（大小为4字节），分别指向两个长度为4的类型为int的数组。</p>
<figure data-type="image" tabindex="5"><img src="https://pic4.zhimg.com/80/v2-6590cb935ae8bf3b7241cb309fe041d7_hd.jpg" alt=""></figure>
<p> 所以当我们传递一个数组引用给一个方法时，数组的元素是可以被改变的，但是无法让数组引用指向新的数组。</p>
<p> 你还可以这样声明：int[][] arr3 = new int[3][]，这时内存情况如下图</p>
<figure data-type="image" tabindex="6"><img src="https://pic2.zhimg.com/80/v2-fdc86227021d56a02b559d6485983c71_hd.jpg" alt=""></figure>
<p> 你还可以这样 arr3[0] = new int [5]; arr3[1] = arr2[0];</p>
<figure data-type="image" tabindex="7"><img src="https://pic1.zhimg.com/80/v2-fdc5e737a95d625a47d66ab61e4a2f55_hd.jpg" alt=""></figure>
<h2 id="关于string">关于String：</h2>
<p> 原本回答中关于String的图解是简化过的，实际上String对象内部仅需要维护三个变量，char[] chars, int startIndex, int length。而chars在某些情况下是可以共用的。但是因为String被设计成为了不可变类型，所以你思考时把String对象简化考虑也是可以的。</p>
<p> String str = new String(&quot;hello&quot;);</p>
<figure data-type="image" tabindex="8"><img src="https://pic4.zhimg.com/80/v2-a143d0a3594d06f54c6853c46c429e08_hd.jpg" alt=""></figure>
<p> 当然某些JVM实现会把&quot;hello&quot;字面量生成的String对象放到常量池中，而常量池中的对象可以实际分配在heap中，有些实现也许会分配在方法区，当然这对我们理解影响不大。</p>
]]></content>
    </entry>
</feed>