<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2021-01-13T23:10:59.005Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[OS：CPUの仮想化ープロセス]]></title>
        <id>https://zy080080.github.io/post/OENVD2_g7/</id>
        <link href="https://zy080080.github.io/post/OENVD2_g7/">
        </link>
        <updated>2021-01-14T00:09:26.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第二章まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第二章まとめ</p>
<!-- more -->
<p></p>
<p>プロセス：ユーザの代わりにOSに対してリソースを要求するとともに，リソースの割り当てを受ける単位。システムが処理する仕事の単位。</p>
<p>プロセス処理形態</p>
<ul>
<li>ユニプロセッサ・ユニプログラミング方式
<ul>
<li>１つのCPUに対して１つのプロセス</li>
<li>バッチ処理</li>
</ul>
</li>
<li>ユニプロセッサ・マルチプログラミング方式
<ul>
<li>１つのCPUに対して複数のプロセス</li>
<li>TSS（Time　Sharing　System　時分割処理方式）</li>
</ul>
</li>
<li>マルチプロセッサ・マルチプログラミング方式
<ul>
<li>複数のCPUに対して複数のプロセス</li>
<li>並列・分散処理</li>
</ul>
</li>
</ul>
<p><strong>同時実行できるプロセス数よりCPUが多いとCPUが遊んでいてもったいないため，プロセスをさらに小さい単位に分割。</strong></p>
<p><strong>スレッド</strong>：CPUリソースが割り当てられる論理単位。</p>
<ul>
<li>CPUリソースをスレッドごとに割り当て</li>
<li>プログラムの実行においては，スレッドは１つの命令の流れとしてとらえることができる。</li>
<li>利点
<ul>
<li>TSSによる切り替えオーバヘッドが軽い
<ul>
<li>同一プロセスから生成されてるから<strong>メモリ領域が同じ</strong>。</li>
<li>メモリ使用量は<strong>1プロセス分</strong>で済む。</li>
<li><strong>別名：Light Weight Process</strong></li>
<li>マルチスレッドの場合，各スレッドは，独自にレジスタ群とスタックを持つともに，CPUリソースのwリアて単位となる。その他，プロセス内で管理される主記憶，プログラム領域，静的変数領域，動的変数領域，PSWなどが，各スレッド間で共有される。また，ファイル情報をプロセス単位で管理されるため，スレッドの生成が軽量（早い）である。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>プロセスとスレッドの違い：</p>
<ul>
<li>プロセス
<ul>
<li>Microsoft Word</li>
<li>Microsoft Excel</li>
<li>各プログラムはプロセスとして処理</li>
</ul>
</li>
<li>スレッド
<ul>
<li>Wordの場合，印刷，編集など，同じ『Word』というプログラムの中で<strong>同時（並行）動作できる単位</strong>                                                                                           |<br>
<strong>イベント</strong>：CPU内での通常の計算処理以外の事象。</li>
</ul>
</li>
</ul>
<p><strong>インターバルタイマー</strong>：TSSで用いる一定時間ごとに決まったイベントを発生させるための装置。</p>
<ul>
<li>TSSでは，定期的な切り替えが必要。インターバルライマが定期的に割込みを発生することで切り替えを実現する。</li>
</ul>
<p><strong>割込み</strong>：通常のCPU演算動作とは異なる事象のこと。</p>
<ul>
<li>キーボード入力を受け取ったなど</li>
<li>割込み発生時にプロセスの切り替えが起こる。</li>
</ul>
<p><strong>割込み処理</strong>：割り込みが発生した時に，CPUには非常に高速かつ軽量に処理するプログラムを実行可能なプログラム実行方式。</p>
<ul>
<li>内部割り込み
<ul>
<li>スーパバイザコール割込み</li>
<li>プログラムチェック（例外）割込み</li>
<li>実行中のプログラムを発生原因とする</li>
<li>プログラム自体の異常など</li>
</ul>
</li>
<li>外部割り込み
<ul>
<li>入出力割込み</li>
<li>タイマ割込み</li>
<li>マシンチェック割込み（冷却装置の異常，電源装置の異常など）</li>
<li>リスタート割込み</li>
<li>その他の要因で発生する</li>
<li>ほかの優先的処理からの要求，ハードウェア異常など</li>
</ul>
</li>
</ul>
<p><strong>スーパバイザモード</strong>：OSを実行するモードであり，CPUが有する全ての命令とOSが管理する全てのリソース扱うことが可能。</p>
<p><strong>ユーザモード</strong>：ユーザの作成した応用プログラムを実行するモードであり，実行できる命令や利用できるリソースに制限がある。</p>
<p><strong>スーパバイザコール割込み</strong>：ユーザプログラムがOSに対して処理を依頼する際に発生する割込み。</p>
<ul>
<li>この時にCPUの実行モードが切り替わる</li>
</ul>
<p><strong>例外割込み（プログラムチェック割込み）</strong>：実行中のプログラムで以上が起こった時に発生する割込み。</p>
<p><strong>割込み処理ルーチン</strong>：割込みハンドラ，割込み処理プログラム。</p>
<p><strong>PSW(Program Status Word)プログラム状態語</strong>：CPU内のプロセスの再開必要なレジスト情報。</p>
<ul>
<li>プログラムカウンタの値</li>
<li>スタックレジスタの値</li>
<li>汎用レジスタの値</li>
<li>割込みマスク（割り込みを禁止すること）の値など</li>
</ul>
<p><strong>PCB(Process Control Block)プロセス制御ブロック</strong>：メモリ上の，PSWを待避するための領域。</p>
<ul>
<li>プロセス識別子　各プロセスに割当てられる一連の番号</li>
<li>PSW　中断時に伝送されたPSW情報</li>
<li>ユーザ名　プロセスの所有者</li>
<li>実行優先度　プロセスに与えられている実行優先度</li>
<li>既実行時間　プロセスがすでにCPUリソースを消費した時間。実行優先度とともに，スケジューリングに用いる。</li>
<li>リソース情報　プロセスの確保しているリソース情報</li>
</ul>
<p><strong>割込みベクタ</strong>：割込みの種類に対応する数字（ID）<br>
割込み処理ルーチン内では，割込みの種類を解析し，その割込みの種類に応じた処理ルーチンを実行する</p>
<p><strong>割込みベクタテーブル</strong>：割込み処理ルーチンは，あらかじめ処理の内容に応じて，実行する処理の番地をテーブル化したもの。<strong>処理の高速化を図る</strong>。<br>
割込み処理ルーチンはメインメモリ上にある割込みベクタテーブルと，システムバス上の割込みベクタ番号から，次に実行するアドレスを迅速に決定する。</p>
<p><strong>実行状態（running）</strong>：プロセスを実行している状態。リソースは，そのプロセスのために確保されている。</p>
<p><strong>実行可能状態（ready）</strong>：実行できるが，CPUリソースが確保できていない状態。CPUリソースを確保した時点で実行開始される。</p>
<p><strong>待ち状態（waiting）</strong>：CPU以外のリソースも確保できていない状態。入力待ちなどもこれに含まれる。</p>
<hr>
<p>1.プロセスの中断，再開は，<strong>割り込み</strong>により行う。割り込みが発生した場合，オペレーティングシステムは，<strong>割込み処理ルーチン</strong>にただちに処理を切り替える。割込み処理ルーチン内で，まず実行中のPSWを主記憶内に伝送し，次にCPUスケジューラを起動させ，そして実行するプロセスを選ぶ。最後に，実行するプロセスのPSWをCPU内に伝送することにより，新しいプロセスを再開する。これら一連の処理を<strong>コンテキスト切り替え</strong>と呼ぶ。</p>
<p>2.OS内におけるプロセスは，全ての実行に必要なリソースを獲得して実行中の<strong>実行状態</strong>(Running)，CPU以外のリソースは全て獲得CPUリソースさえ獲得できれば<strong>実行可能状態</strong>(ready)，CPU以外のリソースの不足，もしくは他のプロセスからのデータ待ちの<strong>待ち状態</strong>(wait)，の３つの状態で存在する。</p>
<p>2.1<br>
　OS内におけるプロセスの状態は，（実行状態），（実行可能状態），（待ち状態）の３つの状態に分けることができる。（実行状態）から（実行可能状態）への状態遷移は優先度の高いプロセスの割込みや，CPUスケジューラにより割り当てられたCPU時間（クオンタム）を使った時に起こる。<br>
　プロセスの実行情報は，主にレジスタ情報が（PSW）に，それ以外の実行時間やプロセス名などの情報が（PCB）に格納されている。実行中のプロセスが中断された場合，これらの情報を保存しなければならない。この一連の操作を（コンテキスト）切り替えと呼び，最近のCPUには（PSW）を高速に保存する仕組みがある。</p>
<p>2.2 割込み時に，割込みの種類をベクタとして，割込み処理ルーチンに渡すのはなぜか，また，ベクタとして渡す以外の他の方法についても考査せよ。<br>
　割込みは，頻繁にかつ様々な原因で発生するため，その処理はできる限り高速に行わなければならない。割込みベクタを用いることで，OSは制御がどのアドレスに移されたかにより，割込みの原因を高速かつ容易に知ることができる。<br>
　また，割込みベクタを用いない方法として，状態（cause）レジスタを用いる方法がある。この場合，割り込みが発生した時点で，同一の割込み処理ルーチンに制御が移り，割込み処理ルーチン内で，状態レジスタを参照することにより，適切な割込み処理を行う。</p>
<p>2.3 OSを理解する上で，速度オーダーの理解は重要である。本書が想定する以下の速度を答えよ</p>
<ul>
<li>CPUの１命令実行   10^(-9)</li>
<li>主記憶からCPUに内容を伝送する速度 10^(-7)</li>
<li>2時記憶の読み出し（書き込み速度） 10^(-3)</li>
<li>人の反応速度  10^(-1)</li>
</ul>
<p>2.4 PCBの場合はA，PSWの場合はB，どちらにも含まれない場合はC<br>
プロセス識別子（A）  ユーザ名（A）    既実行時間（A）  実行優先度（A）  プログラムカウンタ（B）<br>
割込みマスク（B）    割込みベクタテーブル（C）    割込み処理ルーチン（C）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：OSとは]]></title>
        <id>https://zy080080.github.io/post/mq2xVP1Fs/</id>
        <link href="https://zy080080.github.io/post/mq2xVP1Fs/">
        </link>
        <updated>2021-01-11T11:25:54.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第1章　要点まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第1章　要点まとめ</p>
<!-- more -->
<p>オペレーティングシステムは，ハードウェアの確保，ユーザインタフェース，入出力制御など，プログラム本体とは異なる制御を，プログラマが意識することなく，プログラムすることを可能とする一連の制御プログラムの集合体なのである。</p>
<p><strong>仮想化</strong>：オペレーティングシステムは『ハードウェアへのアクセスの容易性』，『ハードウェアリソースの確保の確認に対する容易性』を確保するために，有限個しかないハードウェアリソースを無限個，無限大のハードウェアリソースとしてプログラム側に提供すること。</p>
<p><strong>多重化</strong>：ハードウェアリソース数を，実際の数より多く見せる操作。</p>
<ul>
<li><strong>時分割多重化</strong>：時間軸上での多重化。時間を区切ることにより，ハードウェアリソースを複数のプログラムに交互に利用させる方式である。</li>
<li><strong>空間分割多重化</strong>：空間軸上での多重化。ハードウェアリソースを複数の領域に区切ることにより，複数のプログラムに別々の領域を利用させる方式である。</li>
</ul>
<p><strong>バッチ処理</strong>：ユーザがジョブをコンピュータに一括して依頼し，コンピュータはプログラムの実行前に一括に投入されたジョブに含まれる情報のみによって処理を行う方式。</p>
<ul>
<li>具体的には，実行時に必要とするリソース（CPU時間，メモリ量など），プログラム本体（ソースコード），データ（入力データ）が投入される。</li>
<li>特徴：実行上必要なリソースを全て実行前に宣言すること。</li>
<li>利点：
<ul>
<li>スケジューリングが単純。
<ul>
<li>前もってプログラムが必要とするリソースが分かる。</li>
<li>複数のジョブのスケジューリングが楽（必要リソースの少ないジョブを優先的に実行すると，全ジョブの平均待ち時間が短くなる）。</li>
<li>ジョブの切り替えも少なくてすむため，無駄が少ない。</li>
</ul>
</li>
</ul>
</li>
<li>欠点：
<ul>
<li>前もって全てを決めないとジョブが投入できない。Ï</li>
</ul>
</li>
</ul>
<p><strong>対話処理</strong>：プログラムの実行中に入力が必要となった場合に，ユーザがその時点で入力を行い，プログラムの実行を制御する処理形態。</p>
<ul>
<li>対話処理を採用する場合の代表的なプロセス実行形態として<strong>タイムシェアリングシステム（時分割処理方式　time sharing sysytem:TSS）</strong></li>
</ul>
<p><strong>クオンタム</strong>：一回に割当てられる時間。</p>
<p><strong>TSS（Time Sharing System 時分割処理方式）</strong>：複数のプロセスに非常に短い時間（10^(-3)秒程度）単位でCPUの実行権を与え，対話処理を実行中の各プロセスにあたかもCPUを占有しているかのように見せかけるCPUの時間軸方向の仮想化手法。(人的反应慢，反应不过来被分配给其他处理的时间，从人的视角来看好像只在处理一个process而已)</p>
<ul>
<li>使っていないCPU時間を他に割り当てる。割り当てられる単位時間（クオンタム）は数10ms。</li>
<li>利点：
<ul>
<li>自分の他に大きなプロセスがあっても，そのプロセスが終わるまで長い時間待たされたりしない。（バッチ処理ではありうる）。各プロセスの待ち時間は短い。</li>
<li>ユーザから見ても，対話的に入力してからその反応が返ってくるまでの時間（レスポンスタイム）が短くなる。</li>
</ul>
</li>
</ul>
<p><strong>リアルタイム処理</strong>：あるジョブやプロセスが発生した時点から決めた時間内に実行を保証する処理。</p>
<p><strong>分散処理</strong>：複数のコンピュータを同時に用いて一連の処理を行う方式。</p>
<hr>
<p>1.<strong>オペレーティングシステム</strong>の目的は，ハードウェアリソース，ソフトウェアリソースの利用時における容易性，効率性の向上である。<br>
2.リソースを配分される単位を<strong>プロセス</strong>と呼び，ユーザから見たコンピュータに依頼する仕事のまとまりを<strong>ジョブ</strong>と呼ぶ。<br>
3.オペレーティングシステムの基本的な枠組みは，リソースの<strong>仮想化</strong>と仮想化されたリソースの<strong>スケジューリング</strong>にある。<br>
4.プログラムの処理形態は，<strong>バッチ処理</strong>と<strong>対話処理</strong>の２つが基本である。他にも，リアルタイム処理や分散処理などオペレーティングシステムの処理形態は広がりつつある。<br>
5.効率化の指標は大きく分けて，プログラムの実行を依頼してから結果が帰ってくるまでの時間の尺度である<strong>レスポンズタイム</strong>（対話処理の場合），<strong>ターンアラウンドタイム</strong>(バッチ処理の場合)と，一定時間内にコンピュータシステムが行う仕事量の尺度である<strong>スループット</strong>がある。</p>
<p>1.1 プロセスとジョブの違いについて説明せよ。<br>
　プロセスは，オペレーティングシステム側から見たリソースの割り当て対象であり，ジョブとは，ユーザ側から見たオペレーティングシステムに対して処理を依頼する，ひとまとまりの仕事を表す。したがって，１つのジョブは通常１つ以上のプロセスから構成される。なお，ジョブという言葉は，バッチシステムでは一般的であり，TSSを基本とするオペレーティングシステムではあまり用いられない。</p>
<p>1.2 空間分割によるリソースの多重化時に考えられるオーバーヘッドについて説明せよ。<br>
　空間分割による多重化を行うためには，プロセスの必要とするリソースがどのような位置に配置されても，プロセス側からは同様のアドレスを指定することにより，アクセスの可能である設計が必要となる。したがって，オペレーティングシステムでは，プロセス側で指定するリソースの位置と実際の物理的なリソースの位置との間の変換を行う作業が必要となる。</p>
<p>1.3 個人が使用するオペレーティングシスレムにおいてもTSSが一般的に用いられている。この理由を，ユーザからみた利便性，システム資源の有効利用の面から考察せよ。<br>
　ユーザからみた利便性：個人が使用するオペレーティングシステムにおいても，複数の仕事を同時に実行することが必要である。ネットワーク入出力，華やかなグラフィカルユーザインターフェース，個人のスケジュール管理ソフトなどなど縁の下の力持ち的なソフトウェアの増加など，ユーザの利便性を追求することを目的とするプロセスは増大の一方である。したがって，複数のプロセスを同時に実行可能なTSS環境は必須である。<br>
　システム資源の有効利用：個人が使用するオペレーティングシステムで実行されているプロセスの大部分は，CPUリソースをほとんど消費しない待ちの状態が多い（ゲームなどCPUリソースを大量に使うアプリケーションの実行時は除く）。例えば，スケジュール管理ソフトは決められた時刻が来た時，もしくはユーザのスケジュール入力時のみ動作すれば良い。したがって，TSSによるCPUリソースの多重化を行っても見かけ上のプログラム実行速度の変化がないだけでなく，待ち時間の有効利用はシステム資源の有効利用となる。</p>
<p>1.4 時分割多重化の利点と欠点<br>
　時分割多重化の利点には，時間を区切ることにより，ハードウェアリソースを複数のプログラムに交互に利用させることができ，CPUなど空間分割が不可能な時に利用できることがある。ただし，欠点として，使用者が切り替わる時に無駄（オーバヘッド）が発生する。電子機械では，短い時間で切り替えるため，切り替え回数が増加すると，オーバヘッドも増加してしまう。</p>
<p>数値の重要性</p>
<ul>
<li>
<p>計算機の基本周期（クロック）は？</p>
<ul>
<li>１単位の処理時間10<sup>(-9)秒(1ns)，クロックだと10</sup>9回(1GHz)</li>
</ul>
</li>
<li>
<p>主記憶へのアクセス遅延は？</p>
<ul>
<li>10^(-7)秒(100ns)</li>
</ul>
</li>
<li>
<p>2次記憶へのアクセス遅延は？</p>
<ul>
<li>10^(-2)秒(5ms~10ms)</li>
</ul>
</li>
<li>
<p>人間のキーボード入力速度は？</p>
<ul>
<li>10^(-1)秒</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[コンパイラ：字句解析]]></title>
        <id>https://zy080080.github.io/post/u0YDg1pii/</id>
        <link href="https://zy080080.github.io/post/u0YDg1pii/">
        </link>
        <updated>2020-10-10T05:35:39.000Z</updated>
        <summary type="html"><![CDATA[<p>コンパイラが行う最初の処理が字句解析である。字句解析では，文字の並びを解析し，トークンの並びへ変換する作業をする。</p>
]]></summary>
        <content type="html"><![CDATA[<p>コンパイラが行う最初の処理が字句解析である。字句解析では，文字の並びを解析し，トークンの並びへ変換する作業をする。</p>
<!-- more -->
<h2 id="トークン">トークン</h2>
<p>ソースプログラムを構成する単位は，文字である。この文字を一文字以上集めて，“単語”に相当する単位にしたものがトークンである。</p>
<p>コンパイラは構文解析を行う前に，文字の並びをトークンの並びに分解する。これは，構文解析をやりやすくするためや，処理方式に違いがあることなどから，一般的に行われるものである。</p>
<p>トークンの並びに変換する作業を，文字の列を句（トークン）の列に分解する作業であることから，**字句解析（Lexical Analasis）**と呼ぶ。</p>
<h2 id="トークンの種類">トークンの種類</h2>
<h3 id="識別子とキーワード">識別子とキーワード</h3>
<p>識別子は，通常の変数名や関数名のような名前を意味する。しかし，変数名か関数名かといった区別は，字句解析では判断できないため，予約語を除き，全て識別子という区分で扱うことになる。</p>
<p>通常のプログラミング言語では，‘if’や‘while’のような単語を，キーワードあるいは予約語（reserved word）として特別に扱っている。</p>
<p>このキーワードは，２つのグループに分けられる。<br>
１つは，ifやwhileのように，プログラムの構造を示すものであり，他のものに定義をされると解析が困難になるため，予約されている。<br>
もう１つは，intやfloatのように，特別なデータ型を表すもので，他のものに定義されても解析上は支障がないが，意味などで混乱を起こす可能性があるため，他の定義が禁止されている。</p>
<h3 id="定数">定数</h3>
<p>（1）整数<br>
コンパイラ内部で扱う時に，整数のオーバーフローが起きてはいけない。</p>
<p>（2）浮動小数点数<br>
3.2や0.25のほか，3.5e2や2e-4も浮動小数点数である。さらに，eの前後に空白を許すか許さないか，といった書き方の違いもあり，これらをか使うプログラミング言語に応じて正しく認識する必要がある。また，誤差の問題も注意が必要である。</p>
<p>（3）文字と文字列<br>
エスケープ文字（C言語の「\」）の扱いを必要とする。また，文字列と文字が異なるのかどうかの違いがある。<br>
C言語では，'a'は文字で，&quot;a&quot;は文字列となる。ところが，Pascalでは'a'は文字で，'ab'が文字列である。そして，文字として'を含める時にどのように記載するかは言語によって違っている。</p>
<h3 id="空白改行注釈">空白，改行，注釈</h3>
<p>空白や改行は，C言語では，トークンの区切りという意味だけを持っている。<br>
注釈は一般にプログラムを構成する要素ではない。<br>
通常のプログラミング言語では，１つのトークンの間に注釈や空白を入れることはできない。</p>
<h2 id="字句解析の手法">字句解析の手法</h2>
<p>字句解析の処理は，入力文字に対する遷移図（オートマトン）と考えると比較的わかりやすい。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[コンパイラ：プログラムが動作する仕組みと言語が動作する仕組み]]></title>
        <id>https://zy080080.github.io/post/a4vitZ301/</id>
        <link href="https://zy080080.github.io/post/a4vitZ301/">
        </link>
        <updated>2020-10-03T04:06:13.000Z</updated>
        <summary type="html"><![CDATA[<p>コンパイラの役割はプログラミング言語を用いて開発するソフトウェア，つまり人が記述したテキストをコンピュータが解釈，実行できる機械語に変換することである。<br>
ここでは，コンパイラの目的を理解するために，コンピュータ上でソフトウェアが動作する基本的な仕組みと，プログラミング言語として定義された文法，さらに，この文法にしたがって開発するソフトウェアの目的を説明する。</p>
]]></summary>
        <content type="html"><![CDATA[<p>コンパイラの役割はプログラミング言語を用いて開発するソフトウェア，つまり人が記述したテキストをコンピュータが解釈，実行できる機械語に変換することである。<br>
ここでは，コンパイラの目的を理解するために，コンピュータ上でソフトウェアが動作する基本的な仕組みと，プログラミング言語として定義された文法，さらに，この文法にしたがって開発するソフトウェアの目的を説明する。</p>
<!-- more -->
<h2 id="コンピュータの仕組み">コンピュータの仕組み</h2>
<p>基本的な構成要素は，頭脳となるCPUと情報を記憶するメモリである。<br>
CPUはメモリに記録されているプログラムを制御装置に読み出して分析，解釈し，演算装置が，その意味を理解しながら実行する。<br>
CPUは人が支持する人間の言葉を直接的に理解できないため，プログラムとして記述された指示書を読みながら実行することになる。この指示書を記述する文法がプログラミング言語である。コンピュータが理解できる言語は，CPUとメモリが連携して行う計算処理の手順を定義できなければならない。<br>
ここで注意すべき点は，<strong>現在のコンピュータは定義されていないことや矛盾する手順を人間のように自動的に発見して補正する能力も知識もない</strong>ことである。</p>
<p>CPU内部にも，計算に用いる数値を格納するレジスタと呼ばれる一種の記憶装置を保持している。計算を行う演算装置は，このレジスタに記録されている数値を読み取り，また一時的な計算結果を書き出しながら計算を実行していく。レジスタは演算装置とのやりとりを高速に行えるが，利用できる数は限定的である。<br>
この構成からCPUの計算速度が向上する，つまりコンピュータ性能が高くなるためには，まず演算装置が高速に計算できること，加えてレジスタへの読み込み，書き込みが高速にできること，さらに一度にレジスタに読み込める情報量を大きくすることが必要になる。</p>
<p>計算手順と計算に用いる情報を定義しているプログラムは，実行する前にはハードディスクなどに格納されている。利用者がプログラムの起動をコンピュータに指示すると，プログラムがメモリに記録（ロード）される。そして，CPUは記憶装置から，順次，計算単位を一時的に内部記憶装置に読み込みながら，このデータに対して計算を加えて，結果を記憶装置に登録する手順を繰り返す。以上の操作により，利用者は最終的に期待する計算結果を得ることができる。</p>
<h2 id="言語が動作する仕組み">言語が動作する仕組み</h2>
<ul>
<li>自然言語（Natural Language）
<ul>
<li>自然発生的にできた言語。日本語，英語が該当する。</li>
</ul>
</li>
<li>人工言語（Artificial Language）
<ul>
<li>ある情報を伝える目的のために人が作り出した言語。モールス信号やプログラミング言語が該当する。</li>
</ul>
</li>
</ul>
<p>人工言語であるプログラミング言語は自然言語と異なり，コンピュータが解釈して実行できるように人が設計した言語であるため，その解釈は厳密的に行われなければならず，曖昧な表現は許されない。</p>
<p>コンピュータには通常，あらかじめ定義されている一通りの意味でしか解釈できない。このように人工言語に属するプログラミング言語は，自然言語と比較して目的が限定的であり，かつ表現力に乏しい言語といえる。</p>
<h3 id="プログラミング言語と機械語">プログラミング言語と機械語</h3>
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1601697611773.png" alt="" loading="lazy"></figure>
<p>プログラミング言語は，人が目的に応じてアルゴリズムを記述しやすいように開発された人工言語であるため，プログラムをCPUが理解できる機械語で表現されるコードに置き換えて解釈する仕組みが必要となる。</p>
<p>この変換を行うツールとして，コンパイラー，インタプリタ，クロスコンパイラなどの処理形態がある。</p>
<p>機械語プログラムは起動するために必要な初期情報を格納したスタートアップルーチンと呼ばれる情報を持ち，<strong>コンピュータの仕組みに対応して</strong>命令群とデータ群を保持している。<br>
コンピュータに動作させたい手順は，スタートアップルーチンを呼び出したのち，命令群とデータ群による計算を繰り返すことにより実行される。<br>
このため，コンパイラがプログラムを機械語に変換してアルゴリズムを実行させるためには，コンピュータの仕組みを強く意識することが重要である。</p>
<figure data-type="image" tabindex="2"><img src="https://zy080080.github.io//post-images/1601698151224.png" alt="" loading="lazy"></figure>
<p>コンパイラを設計する際に行われる検討項目を以下に示す。これらの検討は，プログラムから機械語への変換を効率よく行うとともに，コンピュータ性能を十分に生かすことが可能な機械語コードを生成するために行う。</p>
<ul>
<li>木（解析木など）や中間言語（アセンブラ）など言語の構造の整理</li>
<li>生成する機械語の構造</li>
<li>プログラムの構造や意味に対応した字句，構文，意味解析</li>
<li>機械語コードの生成と最適化</li>
<li>コンパイラやインタプリタ，プリプロセッサ，マクロなど，言語処理の形態</li>
<li>プートストラップ，コンパイラの自動生成，コンパイラ作成などのツール利用</li>
</ul>
<h2 id="言語を動作させる工夫">言語を動作させる工夫</h2>
<p>コンピュータのCPuに依存する言語を，一般に低レベル言語と呼ぶ。これに対して手続き型言語，関数型言語，論理型言語，オブジェクト指向型言語など，プログラムとして表現したい意味に依存して設計された言語は，特定のCPU種別に依存することなく独立に開発されるため，高レベル言語と呼ばれる。</p>
<hr>
<h2 id="コンパイラ">コンパイラ</h2>
<p>コンパイラは高級言語で書かれたプログラムをそれと等価な機械語プログラム等に変換する言語処理系（Language Processing System）である。</p>
<h2 id="言語処理系">言語処理系</h2>
<p>あるプログラミング言語で書かれたプログラムを，同じ動作をする別のプログラミング言語のプログラムに変換するソフトウェアを言語処理系という。</p>
<p>変更前のプログラム＝ソース ，その言語＝ソース言語<br>
変更後のプログラム＝オブジェクト，その言語＝オブジェクト言語（目的言語）</p>
<p>Cコンパイラ（言語処理系）<br>
ソース言語＝C言語，目的言語＝アセンブリ言語</p>
<p>アセンブラ（言語処理系）<br>
ソース言語＝アセンブリ言語，目的言語＝機械語</p>
<h2 id="リンカ">リンカ</h2>
<p>オブジェクトファイルとライブラリを結合し，動作可能な実行形式プログラムを出力。</p>
<h2 id="プリプロセッサ">プリプロセッサ</h2>
<p>ソースプログラムをコンパイル可能な形に整える。ヘッダーファイルの取り込み，マクロ展開（#defineなど）</p>
<h2 id="分割コンパイル">分割コンパイル</h2>
<p>システム開発は，通常複数人のチームで行う。<br>
そのため，一般的ににプログラムは複数のソースプログラムによって構成される。</p>
<ul>
<li>各ソースプログラムを個別にコンパイルして結合することを<strong>分割コンパイル</strong>という。</li>
<li>個別にコンパイルしたオブジェクトファイルの結合は，リンカーが行う。</li>
<li>各ソースプログラムは完全ではないため，Cコードと呼ぶことがある。</li>
</ul>
<h2 id="コンパイラの構造">コンパイラの構造</h2>
<p>コンパイラの本体は，以下の４つの処理で構成される。</p>
<ol>
<li>字句解析（Lexical Analysis）ソースプログラムのテキストを，字句要素（lexeme）と呼ばれる文字列に分割する。</li>
<li>構文解析（Syntax Analysis）トークン列を解析して文法にしたがっているかを確認し，構文木を生成する。</li>
<li>意味解析（Semantic Analysis）意味の観点でプログラムの正しさを確認する。</li>
<li>コード生成（Code Generation）アセンブリ言語のコードを生成する。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Frameworkの特徴と役割]]></title>
        <id>https://zy080080.github.io/post/7zzNKr8JI/</id>
        <link href="https://zy080080.github.io/post/7zzNKr8JI/">
        </link>
        <updated>2020-09-29T13:07:33.000Z</updated>
        <summary type="html"><![CDATA[<p>アプリケーションやシステム開発においては，開発効率を向上させるためにフレームワークを使用する企業は少なくありません。<br>
Javaの開発環境でよく使用されるフレームワークはSpring Framework。</p>
]]></summary>
        <content type="html"><![CDATA[<p>アプリケーションやシステム開発においては，開発効率を向上させるためにフレームワークを使用する企業は少なくありません。<br>
Javaの開発環境でよく使用されるフレームワークはSpring Framework。</p>
<!-- more -->
<h2 id="従来のwebアプリケーションの問題点">従来のWebアプリケーションの問題点</h2>
<p>一般的に，JavaのWebアプリケーションでは，レイヤー構造を採用します。</p>
<table>
<thead>
<tr>
<th>レイヤー</th>
<th>役割</th>
</tr>
</thead>
<tbody>
<tr>
<td>プレゼンテーション・レイヤー</td>
<td>クライアントの画面表示や画面からの入力を受け付ける</td>
</tr>
<tr>
<td>ビジネス・レイヤー</td>
<td>業務処理を行う</td>
</tr>
<tr>
<td>データアクセス・レイヤー</td>
<td>データベースなどのリソースにアクセスする</td>
</tr>
</tbody>
</table>
<p>Webアプリケーションは，レイヤーによって論理的に分割され，各レイヤーでは様々なフレームワークを使用して効率的に開発を行います。<br>
例えば，プレゼンテーション・レイヤーにはStruts，データアクセス・レイヤーにはHibernateを使うといった具合です。</p>
<p>このように各レイヤーごとに，フレームワークを適用して開発する方式はかなり一般的になりましたが，実際にプログラムを作っていく上で，いくつかの問題が出てきました。</p>
<h3 id="変更に弱い">変更に弱い</h3>
<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1601360542249.jpg" alt="" loading="lazy"></figure>
<p>各レイヤーは一見独立しているように見えるのですが，実際のところ，隣り合うレイヤーは密接に連結しています。例えば，ビジネス・レイヤーからデータアクセス・レイヤーのオブジェクトにアクセスする場合，通常は以下のようなプログラムになるでしょう。</p>
<pre><code>DataAccessObject dao = new DataAccessObject();
</code></pre>
<p>これは，データアクセス・レイヤー（DataAccessObjectメソッドなど）に変更があった場合，呼び出し元のビジネス・レイヤーにも変更が発生することを意味しています。できるならば，データアクセス・レイヤーの変更だけに留めたいものです。</p>
<h3 id="単体テストが困難">単体テストが困難</h3>
<p>レイヤー同士が密接に連結している場合，単体テストが困難になります。例えば，ビジネス・レイヤーの単体テストをする場合，しぞんしているレイヤーの環境，つまり，データアクセス・レイヤーの実装とデータベース環境が必要となります。ビジネス・レイヤーのテストをしたいだけなのに，わざわざデータベースを用意してテストデータを投入するというのは面倒です。</p>
<p>また，複数のレイヤーをまとめてテストすると，エラーが発生した時に何が原因でエラーになったのか，切り分けの手間が増えます。可能ならば，ビジネス・レイヤー単体で試験したいものです。</p>
<h3 id="トランザクションコードが散在">トランザクション・コードが散在</h3>
<p>データベースにアクセスするアプリケーションでは，データベースのトランザクションを処理するコードがプレゼンテーション・レイヤーやビジネス・レイヤーに散在します。プログラムのメンテナンスのしやすさや再利用性を考えると，トランザクション・コードは分離して，まとめて管理したいところです。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/images/spring-overview.png" alt="" loading="lazy"></figure>
<h2 id="spring-frameworkの特徴">Spring Frameworkの特徴</h2>
<p>Spring Frameworkの特徴として，AOPとDiと呼ばれる概念で構築されていること，専用のテストプログラムがあることなどが挙げられます。</p>
<h3 id="diにより変更がしやすい">DIにより変更がしやすい</h3>
<p>Dependency Injection，依存性の注入と言います。<br>
DIを重視した設計になっていると，依存性のあるプログラムを外部から取り入れできるようになります。<br>
オブジェクトを注入することより，クラスの依存関係が解消され，動作のテストを行えるようになります。結果として，１つひとつのプログラムを独立させやすくなり，システム開発や改修が楽になるのです。</p>
<h3 id="aopによりメンテナンスがしやすい">AOPによりメンテナンスがしやすい</h3>
<p>AOPとは，Aspect Orientation Programmingの略で，アスペクト指向プログラミングと言います。<br>
システム内で行われる同じ処理（共通処理）を抽出して集約をするプログラミング手法で，プログラムをシンプルにまとめることができます。コードを短くわかりやすくすることで，不具合の特定が容易になるほか，プログラムの修正も行いやすくなります。</p>
<h3 id="開発に役立つテストプログラムがある">開発に役立つテストプログラムがある</h3>
<p>１つひとつのシステムを統合した際のバグ検出ができる専用テストプトグラムがあります。開発したシステムが問題なく処理できるかを事前にチェックすることで，バグを最小限に抑えられるようになります。</p>
<p>参照：<br>
<a href="https://hnavi.co.jp/knowledge/blog/spring-framework/">https://hnavi.co.jp/knowledge/blog/spring-framework/</a><br>
<a href="https://xtech.nikkei.com/it/article/COLUMN/20070710/277218/">https://xtech.nikkei.com/it/article/COLUMN/20070710/277218/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git：分散型バージョン管理〜チーム開発　メモ]]></title>
        <id>https://zy080080.github.io/post/l0qMHfM-n/</id>
        <link href="https://zy080080.github.io/post/l0qMHfM-n/">
        </link>
        <updated>2020-09-29T05:17:27.000Z</updated>
        <summary type="html"><![CDATA[<p>ブランチによるチーム開発はGitの特徴であり，Gitが多くの開発者に支持される理由となる機能である。</p>
]]></summary>
        <content type="html"><![CDATA[<p>ブランチによるチーム開発はGitの特徴であり，Gitが多くの開発者に支持される理由となる機能である。</p>
<!-- more -->
<h2 id="中央リポジトリをクローン">中央リポジトリをクローン</h2>
<pre><code>git clone https://openg.tracpath.com/git/project project
</code></pre>
<p>git cloneコマンドで「project」中央リポジトリからローカルリポジトリを作成した。</p>
<h2 id="オーカルリポジトリから中央リポジトリにプッシュ">オーカルリポジトリから中央リポジトリにプッシュ</h2>
<pre><code>git push
</code></pre>
<h2 id="プルの使い方">プルの使い方</h2>
<p>git pullコマンドは，中央リポジトリの最新情報を取得し(git fetch)，自分の作業ディレクトリと統合(git merge)することを意味している。</p>
<p>pullの操作を行うタイミング：</p>
<ul>
<li>開発作業を開始する前に</li>
<li>作業が完了し，pushする前にpull操作を行う</li>
</ul>
<h3 id="中央リポジトリの情報を知る">中央リポジトリの情報を知る</h3>
<pre><code>git remote -v
</code></pre>
<h3 id="pushの使い方">pushの使い方</h3>
<pre><code>git push [romote-name] [branch-name]
</code></pre>
<h2 id="ブランチ">ブランチ</h2>
<p>同時対応が可能なブランチを利用することで，</p>
<ul>
<li>同時に異なる目的の作業を進めることが可能</li>
<li>ブランチはお互いに影響しないため，独立したソースコードとして管理が可能</li>
<li>ブランチでの作業は他のメンバーに影響を与えない</li>
<li>ブランチの作成，マージが簡単に可能</li>
<li>修正内容を戻したり，なかったことにすぐにできる</li>
</ul>
<p>というメリットがある</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch [branch-name]</td>
<td>ブランチを作成する</td>
</tr>
<tr>
<td>git branch -vva</td>
<td>ブランチ一覧を確認する</td>
</tr>
<tr>
<td>git checkout branchName</td>
<td>ブランチを切り替える</td>
</tr>
<tr>
<td>git merge master</td>
<td>ブランチをmasterブランチにマージする</td>
</tr>
<tr>
<td>git branch -d [branch-name]</td>
<td>ブランチを削除する</td>
</tr>
</tbody>
</table>
<h3 id="マージを理解する">マージを理解する</h3>
<p>マージは枝分かれしたブランチを1つに統合することをいう。</p>
<p>コミットされ版を重ねたブランチに対して行うマージ処理は，次の２つを意味している。</p>
<ol>
<li>同一のファイルに行われた変更を統合する</li>
<li>コミットに含まれるファイル全体を統合する</li>
</ol>
<h2 id="タグの使い方">タグの使い方</h2>
<p>タグとは，特定のバージョンに対して目印となるポイントをつけることである。<br>
例えば，Webアプリケーションのリリースした時点のバージョンをタグ名「v.1.0」としたり，受託開発でお客様に納品した時点のバージョンをタグ名「yyyy-mm-dd」と利用する。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git tag [tag-name]</td>
<td>タグを作成する</td>
</tr>
<tr>
<td>git tag</td>
<td>タグの一覧を確認する</td>
</tr>
<tr>
<td>git tag -d [tag-name]</td>
<td>タグを削除する</td>
</tr>
<tr>
<td>git push origin [tag-name]</td>
<td>作成したタグを中央リポジトリにプッシュする</td>
</tr>
<tr>
<td>git push origin :tagname</td>
<td>リモートのタグを削除する</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git：分散型バージョン管理〜Gitの基本　メモ]]></title>
        <id>https://zy080080.github.io/post/BtnRgcd13/</id>
        <link href="https://zy080080.github.io/post/BtnRgcd13/">
        </link>
        <updated>2020-09-24T12:57:22.000Z</updated>
        <summary type="html"><![CDATA[<p>分散型バージョン管理は，個々の開発者ごとに複数のリポジトリを持つことができ，開発の形態や規模に応じて柔軟な開発ができる。</p>
]]></summary>
        <content type="html"><![CDATA[<p>分散型バージョン管理は，個々の開発者ごとに複数のリポジトリを持つことができ，開発の形態や規模に応じて柔軟な開発ができる。</p>
<!-- more -->
<h1 id="git">Git</h1>
<p>これはGitを勉強する際に大切なことや忘れやすいことをまとめた文章である。</p>
<h2 id="gitの仕組み">Gitの仕組み</h2>
<ul>
<li>Gitがスナップショットとしてデータを記録している。その理由は，Gitが持つブランチ機能を使った開発でその力を発揮することができるからである。</li>
<li>ローカルリポジトリを持つため，全ての操作をローカルで完結できます（リモートリポジトリにアクセスする必要がない）。</li>
<li>ローカルリポジトリは自分専用のリポジトリとしてブランチの作成やコミットが可能。</li>
<li>障害が発生し，ローカルリポジトリを失った場合に別のリポジトリから復元が可能。</li>
<li>スポードと大規模プロジェクトでも効率の高い開発が可能。</li>
</ul>
<h2 id="gitの初期設定">Gitの初期設定</h2>
<p>チームで共有するためにユーザー情報が必要となる。</p>
<pre><code>開発者の名前を設定
git config --global user.name &quot;new username&quot;
開発者のメールアドレスを設定
git config --global user.email &quot;user@email.com&quot;
ユーザー名とパスワードのキャッシュを有効にする
git config --global credential helper osxkeychain
git config --global credential helper wincred
git statusなどで日本語ファイル名をエスケープせずに表示する
git config --global core.quotepath false
</code></pre>
<h2 id="gitの三つの状態">Gitの三つの状態</h2>
<ol>
<li>変更がない状態</li>
<li>変更済み：<br>
作業コピーのファイルに変更を加えたり，ファイルを新規作成したりした状態のこと。自分の作業コピー内で修正中、または修正を完了していても，ローカルリポジトリにコミット対象であることを示すマークをつけていない。</li>
<li>ステージ済み状態<br>
バージョン管理対象のファイルが追跡され，マークされた状態。またローカルリポジトリにコミットされていないことを意味する。</li>
</ol>
<h2 id="リポジトリをクローン作成する">リポジトリをクローン/作成する</h2>
<p>作成：<br>
ローカルリポジトリのフォルダを作成し，</p>
<pre><code>git init
</code></pre>
<p>を実行する。</p>
<p>クローン：<br>
git initでリポジトリを準備し，</p>
<pre><code>git clone https://username@domain/path/to/repository
</code></pre>
<p>を実行する。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>git status</td>
<td>作業コピー状態を表示</td>
</tr>
<tr>
<td>git add fileName</td>
<td>新しいファイルをコミット対象としてステージ済みに登録</td>
</tr>
<tr>
<td>git add .</td>
<td>複数のファイルを一度にステージ済みに登録</td>
</tr>
<tr>
<td>git commit -m &quot;message&quot;</td>
<td>変更をコミットする</td>
</tr>
<tr>
<td>git rm fileName</td>
<td>ファイルの削除を実行し，ステージ済みにする</td>
</tr>
<tr>
<td>git mv fileName newFileName</td>
<td>ファイルの名前を変更</td>
</tr>
</tbody>
</table>
<h3 id="コミットメッセージは将来のチームと自分のため">コミットメッセージは将来のチームと自分のため</h3>
<p>コミット時に，-mオプションを付けない場合，コミットメッセージを入力するために，エディターが起動する。<br>
コミットメッセいーじには，そのコミットを説明する内容を記述するようにすべきである。機能追加なのか，バグ対応なのか。。。<br>
人間の記憶は曖昧のため，コミット時のメッセージをできるだけ詳しく記録することが大切。</p>
<p>良い例：<br>
HTTP/2に対応するライブラリを追加<br>
ヘッダーを共通化した（ref　#143）<br>
起動時にクラッシュするバグに対応</p>
<h2 id="ファイルの削除移動と名前変更">ファイルの削除，移動と名前変更</h2>
<p>git rmコマンドは，ファイルの削除を実行して，<strong>ステージングに登録した状態「ステージ済み」にする</strong>。</p>
<pre><code>git rm sample.txt
</code></pre>
<p>ファイルを直接削除した場合も自動で検知する。ただし，自動的に「ステージ済み」にならない。</p>
<p>git mv コマンドはファイル名の変更，ステージング登録を一度に行う便利なコマンドである。</p>
<pre><code>git mv sample.txt newSample.txt
</code></pre>
<h2 id="バージョン管理から対象外にする">バージョン管理から対象外にする</h2>
<p>バージョン管理したくてもよいファイル例</p>
<ul>
<li>~や.swpや.bakで終わるファイル
<ul>
<li>Emacs/Vim/Windows系エディタのバックアップファイル</li>
</ul>
</li>
<li>Thumbs.dbやDS_Store
<ul>
<li>WindowsやMacのOSが出力するファイル</li>
</ul>
</li>
<li>~$で始まるファイル
<ul>
<li>Office関係のファイルを開いたときに生成される隠しファイル</li>
</ul>
</li>
</ul>
<h3 id="対象外を定義するgitignoreを作成する">対象外を定義する「.gitignore」を作成する</h3>
<pre><code>echo &quot;.DS_Store&quot; &gt; .gitignore
</code></pre>
<p>.gitignoreの保存場所は，.gitと同じディレクトリを指定する。</p>
<h3 id="gitignoreファイルの書き方">.gitignoreファイルの書き方</h3>
<table>
<thead>
<tr>
<th>書式</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#</td>
<td>空行や＃で始まる行はコメントとして扱われる</td>
</tr>
<tr>
<td>sample.txt</td>
<td>ディレクトリに関係なくsample.txtを対象外とする</td>
</tr>
<tr>
<td>/sample.txt</td>
<td>.gitignoreが配置されたディレクトリにあるsample.txtを対象外とする</td>
</tr>
<tr>
<td>folder-a/</td>
<td>ディレクトリ以下の全てを対象外とする</td>
</tr>
<tr>
<td>*.log</td>
<td>ファイルの拡張子が.logのファイルを全て対象外とする</td>
</tr>
<tr>
<td>file-[1-9].html</td>
<td>globパターンに一致するファイルを対象外とする</td>
</tr>
</tbody>
</table>
<h2 id="コミットログ履歴を確認する">コミットログ（履歴）を確認する</h2>
<pre><code>git log
</code></pre>
<p>git logでよく使われるオプション</p>
<table>
<thead>
<tr>
<th>オプション</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>各コミットのバッチ情報を表示する</td>
</tr>
<tr>
<td>--stat</td>
<td>各コミットで変更されたファイルの統計情報を表示する</td>
</tr>
<tr>
<td>--numstat</td>
<td>ファイル毎の削除や追加された行数を表示する</td>
</tr>
<tr>
<td>--name-status</td>
<td>変更したファイルを表示する</td>
</tr>
<tr>
<td>-- path/to/*.txt</td>
<td>特定のファイルの履歴を表示する</td>
</tr>
<tr>
<td>--author='xxx'</td>
<td>コミットしたユーザー「xxx」で絞り込み表示する</td>
</tr>
</tbody>
</table>
<p>また，表示形式を指定することが可能である。</p>
<pre><code>git log --oneline --graph --decorate
</code></pre>
<p>とすることで見やすく表示することが可能である。</p>
<h2 id="変更作業のやり直し">変更作業のやり直し</h2>
<pre><code>git reset HEAD sample.txt
</code></pre>
<p>これでsample.txtのステージ済みの状態を取り消した。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MavenでMybatisを使う際のjava.io.IOException: Could not find resource XXX.xmlについて]]></title>
        <id>https://zy080080.github.io/post/OUJh9scJm/</id>
        <link href="https://zy080080.github.io/post/OUJh9scJm/">
        </link>
        <updated>2020-09-17T07:59:22.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://zy080080.github.io//post-images/1600326566880.png" alt="" loading="lazy"></figure>
<p>開発環境はIntelliJ IDEAです。<br>
Mybatisを勉強し始めたところですが，簡単なselect ステートメントを実行すると，java.io.IOException: Could not find resource XXX.xmlという例外が発生しました。</p>
<p>その理由は，srcディレクトリの中のxmlファイルはコンパイルされないからです。<br>
xmlファイルをresourceディレクトリに入れれば解決できます。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[よく使われるストリームのまとめ]]></title>
        <id>https://zy080080.github.io/post/Sjm2Ui3GK/</id>
        <link href="https://zy080080.github.io/post/Sjm2Ui3GK/">
        </link>
        <updated>2020-07-21T13:20:46.000Z</updated>
        <content type="html"><![CDATA[<p>1.ファイルを操作するクラスやメソッドの活用方法<br>
Fileクラス：ファイルおよびディレクトリのパス名の抽象表現である。<br>
Fileクラスを用いたファイル操作やディレクトリ操作方法：<br>
boolean delete()：ファイルの削除。<br>
boolean renameTo(File dest)：ファイルの名前変更する。<br>
boolean exists()：ファイルの存在確認。<br>
String[] list()：ディレクトリ一覧を得る。<br>
File[] listFiles()：ディレクトリ一覧を得る。<br>
boolean mkdir()：指定したディレクトリを単独で作成する。<br>
boolean mkdirs()：ディレクトリが深い場合でも親ディレクトリを含めて作成する。<br>
String getAbsolutePath()：指定したファイルの絶対パスを取得する。<br>
String getPath()：ファイルの相対パスを取得する。</p>
<p>2.色々なストリーム：<br>
バイトストリーム：文字ではない単なるデータ（いわゆるバイナリデータ）を取り扱うためのもの<br>
InputStream：抽象クラスで、バイト入力ストリームを表現するすべてのクラスのスーパー・クラスである。<br>
メソッド：<br>
read()：この入力ストリームからデータのバイトを読み込む。<br>
read()：最大b.lengthバイトのデータを、この入力ストリームからバイト配列に読み込む。<br>
close()：最大b.lengthバイトのデータを、この入力ストリームからバイト配列に読み込む。<br>
よく使うサブクラス：<br>
FileInputStream：ファイル・システム内のファイルから入力バイトを取得するためのクラスである。イメージ・データなどのrawバイトのストリームを読み込むときに使用する。<br>
FileInputStreamのサブクラス：<br>
BufferedInputStream：ほかの入力ストリームに機能、特に入力をバッファに格納する機能とmarkおよびresetメソッドをサポートする機能を追加したクラスである。入力ストリームから必要に応じて一度に多数のバイトが内部バッファに補充される。<br>
DataInputStream：プリミティブ型のJavaデータをベースとなる入力ストリームからマシンに依存せずに読み込むときに使用する。</p>
<p>OutputStream：抽象クラスは、バイト出力ストリームを表現するすべてのクラスのスーパー・クラスである。<br>
よく使うメソッド：<br>
write(byte[] b)：指定されたバイト配列のb.lengthバイトをこの出力ストリームに書き込む。<br>
write(int b)：指定されたバイトをこの出力ストリームに書き込む。<br>
flush()：出力ストリームをフラッシュして、バッファリングされていたすべての出力バイトを強制的に書き込む。<br>
close()：出力ストリームを閉じ、このストリームに関連するすべてのシステム・リソースを解放する。<br>
よく使うサブクラス：<br>
FileOutputStream：FileまたはFileDescriptorにデータを書き込むための出力ストリームである。<br>
FileOutputStreamのサブクラス：<br>
BufferedOutputStream：バッファリングされた出力ストリームを実装したクラスである。<br>
PrintStream：<br>
ほかの出力ストリームに機能、具体的には、さまざまなデータ値の表現を簡易的に出力する機能を追加したクラスである。PrintStreamはほかの出力ストリームとは違って、IOExceptionをスローすることはない。<br>
printlnを呼び出すと，PrintStreamを自動的にフラッシュする。<br>
よく使うメソッド：<br>
さまざまなデータ値を出力するprint()，println()およびprintf()。<br>
close()：ストリームを閉じる。<br>
DataOutputStreamなど。</p>
<p>文字ストリーム：基本的にはテキストを取り扱うためのものである。<br>
Reader：文字ストリームを読み込むための抽象クラスである。<br>
よく使うサブクラス：<br>
InputStreamReader：バイト・ストリームから文字ストリームへの橋渡しの役目を持つ。バイトを読み込み、指定されたcharsetを使用して文字にデコードする。<br>
よく使うメソッド：<br>
read()：単一の文字を読み込む。<br>
close()：ストリームを閉じて、それに関連するすべてのシステム・リソースを解放する。<br>
よく使うサブクラス：<br>
FileReader：文字ファイルを読み込むための簡易クラスである。<br>
BufferedReader：文字、配列、行をバッファリングすることによって、文字型入力ストリームからテキストを効率良く読み込むクラスである。</p>
<p>Writer：文字ストリームに書き込むための抽象クラスである。<br>
OutputStreamWriter：FileまたはFileDescriptorにデータを書き込むための出力ストリームである。<br>
よく使うメソッド：<br>
write(String str, int off, int len)：文字列の一部を書き込む。<br>
write(char[] cbuf, int off, int len)：文字の配列の一部を書き込む。<br>
write(int c)：単一の文字を書き込む。<br>
close()：ストリームを最初にフラッシュして、閉じる。<br>
flush()：ストリームをフラッシュする。<br>
よく使うサブクラス：<br>
FileWriter：文字ファイルを書き込むための簡易クラスである。<br>
PrintWriter：<br>
オブジェクトの書式付き表現をテキスト出力ストリームに出力するクラスである。<br>
このクラスは、PrintStreamで見つかったすべてのprintメソッドを実装する。<br>
ただし、rawバイトを書き込むメソッドは含まれない。<br>
PrintStreamクラスとは異なり、自動フラッシュが有効な場合は、改行文字が出力されるときではなく、println、printf、またはformatのいずれかのメソッドが呼び出されたときにのみ実行される。<br>
よく使うメソッド：<br>
さまざまなデータ値を出力するprint()，println()およびprintf()。これらのメソッドは、改行文字ではなく、プラットフォームに固有の行区切りの表記を使用する。<br>
close()：ストリームを閉じる。<br>
BufferedWriter：文字をバッファリングすることによって、文字、配列、または文字列を効率良く文字型出力ストリームに書き込むクラスである。</p>
<p>3.文字ストリームとバイトストリームの違い<br>
ストリームとは，連続したデータの流れを抽象化したものである。<br>
文字ストリームとは，テキストを取り扱うための，16ビット単位（文字リテラル）で入出力するストリームである。<br>
バイトストリームとは，バイナリデータを取り扱うための，最小単位8ビット単位で入出力するストリームである。<br>
文字ストリームを使用すれば，文字コードに依存しないプログラムを作成可能になる。入力・出力の文字コードに関わらず，Java内部ではUnicodeに変換される。</p>
<p>4.バッファリング<br>
データを二次記憶装置から一時記憶装置にまとめて読み込む処理である。</p>
<p>5.ファイルの最後に書き込みたい場合<br>
FileWriterはFileWriter(File file, boolean append)というコンストラクタを持つ。appendがtrueの場合，バイトはファイルの先頭ではなく最後に書き込まれる。<br>
PrintWriterのコンストラクタに渡せる変数は，File，String，Writer，OutputStreamである。つまり，全てのprintメソッドとファイルの最後に書きたい場合，PrintWriter(new FileWriter(File,true))を使えばよい。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About protected]]></title>
        <id>https://zy080080.github.io/post/nj0dzADHm/</id>
        <link href="https://zy080080.github.io/post/nj0dzADHm/">
        </link>
        <updated>2020-05-08T09:17:56.000Z</updated>
        <summary type="html"><![CDATA[<p>protected variable is a bit interesting in Java</p>
]]></summary>
        <content type="html"><![CDATA[<p>protected variable is a bit interesting in Java</p>
<!-- more -->
<p>Quoted from Core Java 9th Edition</p>
<blockquote>
<p>However, the Manager class methods can peek inside the hireDay field of Manager objects only, not of other Employee objects. This restriction is made so that you can’t abuse the protected mechanism by forming subclasses just to gain access to the protected fields</p>
</blockquote>
<p>Quoted from &quot;Thinking in Java&quot; Fourth Edition p180:</p>
<blockquote>
<p>In an ideal world, the private keyword would be enough. In real projects, there are times when you want to make something hidden from the world at large and yet allow access for members of derived classes.</p>
<p>The protected keyword is a nod to pragmatism. It says “This is private as far as the class user is concerned, but available to anyone who inherits from this class or anyone else in the same package.” (In Java, protected also provides package access.)</p>
<p>Although it’s possible to create protected fields, the best approach is to leave the fields private; you should always preserve your right to change the underlying implementation. You can then allow controlled access to inheritors of your class through protected methods</p>
</blockquote>
]]></content>
    </entry>
</feed>