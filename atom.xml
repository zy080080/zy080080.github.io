<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy080080.github.io/</id>
    <title>听故事的人</title>
    <updated>2021-01-19T05:01:49.968Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy080080.github.io/"/>
    <link rel="self" href="https://zy080080.github.io/atom.xml"/>
    <subtitle>天青色等烟雨，而我在等你</subtitle>
    <logo>https://zy080080.github.io/images/avatar.png</logo>
    <icon>https://zy080080.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 听故事的人</rights>
    <entry>
        <title type="html"><![CDATA[OS：ファイルーより進んだファイルシステム]]></title>
        <id>https://zy080080.github.io/post/PXPlWYWB9/</id>
        <link href="https://zy080080.github.io/post/PXPlWYWB9/">
        </link>
        <updated>2021-01-19T02:18:24.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第14章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第14章　まとめ</p>
<!-- more -->
<p><strong>ライトスルー</strong>：書き込み発生時，ディスクに対しても書き込みを行う。</p>
<p><strong>ライトバック</strong>：書き込み発生時はディスクキャッシュに対してのみ行う。定期的に（数十秒程度）キャッシュの内容を二次記憶にい書き出す。</p>
<p><strong>ジャーナルファイルシステム</strong>：</p>
<ul>
<li>**二次記憶の一部（固定領域）**をジャーナル領域とする</li>
<li>書き込み時
<ul>
<li>ジャーナル領域に，下記の情報を書き込む。
<ul>
<li>空きセクタ確保情報</li>
<li>inode（ファイル、ディレクトリなどのファイルシステム上のオブジェクトに関する基本情報が格納される）確保・更新情報</li>
<li>セクタ書き込み情報</li>
<li>ディレクトリ更新情報</li>
</ul>
</li>
<li>書き込み終了後，プロセスに書き込み完了通知（commit）</li>
<li>非同期に，ジャーナル領域にあるファイル変更情報を用いて，ファイル実体を更新</li>
</ul>
</li>
<li>commit前に異常終了した場合，ファイルの書き込みがなかったものとして扱う
<ul>
<li>ファイル実体の変更はないので，不整合は発生しない。</li>
</ul>
</li>
<li>非同期書き込みの際に停止した場合は
<ul>
<li>再実行すればいい</li>
</ul>
</li>
</ul>
<p><strong>ジャーナルファイルのモード</strong>：</p>
<ul>
<li>Orderedモード
<ul>
<li>データが，ファイル実体に反映された後で，そのデータを管理する<strong>inode情報</strong>，<strong>ディレクトリ情報</strong>のみをジャーナル領域に書き込む</li>
</ul>
</li>
<li>Writebackモード
<ul>
<li>データの保存領域への書き込み終了を待たずに，メタデータをジャーナル領域に書き込む</li>
<li>書き込み性能は向上するが，データの保存が失敗したっばいでもジャーナル領域が更新される可能性がある</li>
</ul>
</li>
<li>Journalモード
<ul>
<li>データの書き込み情報もジャーナル領域に書き込む</li>
<li>確実だが，遅い</li>
</ul>
</li>
</ul>
<p><strong>非同期入出力</strong>：プログラムが実行する入出力の終了を待たずに，次の命令を実行する方式であり，余計な待ち状態への意向をなくすことにより，システムのスループットを向上させる。</p>
<p>ディスクに関する仮想化：</p>
<ul>
<li>ディスクキャッシュ
<ul>
<li><strong>ディスク</strong>上のデータを一部主記憶に置くことで，低速なディスクへの読み書きを<strong>主記憶</strong>アクセス時間で実現する</li>
</ul>
</li>
<li>VFS
<ul>
<li>アプリケーションと二次記憶装置との間に位置する</li>
<li>アプリケーションからのファイル操作要求を，各二次記憶システムごとのAPIに変換</li>
</ul>
</li>
<li>ステージング
<ul>
<li><strong>テープ</strong>等のデータを一部<strong>ハードディスク</strong>に置くことで，低速な二次記憶への読み書きを（比較的高速な二次記憶である）<strong>ハードディスク</strong>へのアクセス時間で実現する。</li>
</ul>
</li>
</ul>
<hr>
<p>1.ファイルシステムの性能向上のために，ファイルを必要とする前に主記憶にあらかじめ読み込み，また書き込みを主記憶にのみ行う<strong>ディスクキャッシュ</strong>が用いられる。</p>
<p>2.入出力の完了を待たずに，入出力関数の終了を呼び出し側プログラムに返す入出力方式として，<strong>非同期入出力</strong>がある。この方式を用いることによりプログラム中で入出力処理と，他の仕事を多重化して実行することが可能となる。</p>
<p>3.様々な二次記憶に対して，統一したアクセス方式を提供するために，ファイルシステムを仮想化する方式が用いられることが多くなった。</p>
<p>(14-1)非同期入出力について以下の問いに答えなさい。<br>
(a)性能が上がる理由<br>
プログラムが実行する入出力命令の終了を待たずに，次の命令を実行するため，余計な待ち状態への移行をなくすことにより，システムのスループットを向上させることができる。</p>
<p>(b)プログラム側で注意する必要のある点<br>
プログラム中で読み込み(書き込み)を依頼した操作の終了を明示的に確認した後，読み込んだ(書き込んだ)データへの処理を行う必要があることに注意する必要がある。</p>
<p>(14-2)ジャーナルファイルのjournal modeにおいて、読み出しが他のモードより遅い理由を示しなさい。<br>
journalモードは，サイズの小さい管理情報だけでなく，書き込みデータもジャーナル領域に書き，さらにジャーナル領域から保存領域にも転送する必要があるため，データがファイル実体に反映された後にinode情報とディレクトリ情報のみを書き込むOrderedモードや，データの保存領域への書き込み終了を待たずにメタデータをジャーナル領域に書き込むWritebackモードよりも遅い。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：ファイルーファイル基礎]]></title>
        <id>https://zy080080.github.io/post/aj_P4T-me/</id>
        <link href="https://zy080080.github.io/post/aj_P4T-me/">
        </link>
        <updated>2021-01-19T02:17:46.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第13章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第13章　まとめ</p>
<!-- more -->
<hr>
<p>ファイルへのアクセス方式は大きく分けて，（順次アクセス）方式と（直接アクセス）方式がある。（順次アクセス）方式は主に（テープ型）デバイスで用いられ，（直接アクセス）方式は（ディスク型）デバイスで用いられる。<br>
　ファイルは，（テープ型）デバイスの場合，（レコード）と呼ばれる単位で読み書きが行われる。プログラム側からみた（レコード）を（論理レコード）と呼び，その（論理レコード）を複数集めて読み書きのオーバーヘッドを軽減した（物理レコード）と呼ばれる単位で，実際にはテープ型デバイスに格納される。<br>
　（ディスク型）デバイスは，（ボリューム）番号，（シリンダ）番号，（トラック）番号，（セクタ）番号を指定することにより，ディスクのどの位置でも読み書き可能であり，最少アクセス単位は（セクタ）単位となり，また，システムによっては複数の（セクタ）を集めた（クラスタ）と呼ばれる単位でのアクセスを行う場合もある。<br>
　ユーザにとって，自由でよりわかりやすい名前をつけることができるために開発されたファイルシステムが（階層化ディレクトリ）である。（階層化ディレクトリ）には，現在プログラムが注目しているディレクトリ上の位置を示す（カレントディレクトリ）と呼ばれる概念が存在し，（カレントディレクトリ）からみた注目ファイルの名前表現を（相対パス）表現と呼び。ルートを起点とする名前表現を（絶対パス）表現と呼ぶ。<br>
　直接アクセス方式では，複数のセクタの間の連結関係を情報として保持する必要がある。その方法に，（リスト）方式と，（インデックス）方式がある。（インデックス）方式は，FATファイルシステムなどで一般的に用いられている。性能向上のために，（インデックス）テーブルを（主記憶）内にあらかじめ読み込むことが行われる。</p>
<p>13.2)ディスクフラグメンテーションを２種類定義し、システム性能低下の定義（どのような性能低下か）と、解決方法についてについて、それぞれ説明しなさい</p>
<p>固定長割り当て時：ハードディスクにおいて，とびとびのセクターをアクセスするために，ヘッドのシーク時間及びトラック内の当該セクターへの移動時間による速度が低下する状態。<br>
性能低下の定義：とびとびのセクタをアクセスするためにヘッドの移動時間によってアクセス速度が低下する。<br>
解決方法：連続領域に再割り当てをする。</p>
<p>連続領域割り当て時：全体的にはハードディスクの容量は十分余っているのに，連続したセクターが割り当てられないことより，使えない細かな領域のみが残ってしまう状態。<br>
性能低下の定義：割り当てに適さない小さな領域が多く発生するほど，ディスクの利用効率が低下する。<br>
解決方法：主記憶領域割り当て時に可変長割り当てをする。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ーページ置き換え方式]]></title>
        <id>https://zy080080.github.io/post/XhbY1TXpf/</id>
        <link href="https://zy080080.github.io/post/XhbY1TXpf/">
        </link>
        <updated>2021-01-19T00:02:07.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第12章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第12章　まとめ</p>
<!-- more -->
<p>静的ページ置き換え方式</p>
<ul>
<li>LRU(Least Recently Used)</li>
<li>LFU(Least Frequently Used)</li>
<li>FIFO(First In First Out)</li>
</ul>
<p><strong>Beladyの例外</strong>：</p>
<ul>
<li>ページフレーム数を増やした時，ページフォルトが増加してしまう現象</li>
<li>原因
<ul>
<li>ページフレーム数により置き換えパターンが変化してしまうアルゴリズム　例）FIFO</li>
</ul>
</li>
</ul>
<p><strong>ワーキングセット方の近似</strong>：</p>
<ul>
<li>ワーキングセットの大きさ＝プロセスに割り当てるページ数
<ul>
<li>ワーキングセットを調べるのはコスト膨大</li>
<li>何らかの方法で近似</li>
</ul>
</li>
<li>ページフォルト発生の平均間隔
<ul>
<li>大きい場合（頻度小）
<ul>
<li>プロセスに与えられているページフレームは比較的十分</li>
</ul>
</li>
<li>小さい場合（頻度大）
<ul>
<li>プロセスには十分なページフレームが与えられていない</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ページフォルト平均間隔＋LRU</strong>：</p>
<ul>
<li>ワーキングセット方の近似とLRUの組み合わせ</li>
<li>プロセスに割り当てるページフレーム数を<strong>動的</strong>に変更</li>
<li>アルゴリズム
<ul>
<li>ページフォルトの平均間隔を計算</li>
<li>平均間隔がある値より小さい場合
<ul>
<li>プロセスに与えるページフレーム数を増やす</li>
</ul>
</li>
<li>平均間隔がある値より大きい場合
<ul>
<li>プロセスに与えるページフレーム数を減らす</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>1.ページ置き換え方式として，プロセスの生成時にプロセスに与えるページ数を決定する<strong>静的ページ置き換え方式</strong>と，プロセスの実行中にプロセスに与えるページ数が変化する<strong>動的ページ置き換え方式</strong>がある。</p>
<p>2.ページ置き換えアルゴリズムとして，<strong>最長不使用ページ置き換え（LRU）アルゴリズム</strong>，<strong>最低使用頻度順ページ置き換え（LFU）アルゴリズム</strong>，<strong>到着順ページ置き換え（FIFO）アルゴリズム</strong>などがある。</p>
<p>3.プロセスに与えるページ数を増やした結果，ページフォルト回数が増加してしまうBeladyの例外という現象がある。このような性質を持たないページ置き換えアルゴリズムを<strong>スタックアルゴリズム</strong>と呼ぶ。</p>
<p>4.動的ページ置き換えにおいて，プロセスに与えるページ数を決める手法として，プロセスが直近にアクセスしたページ集合（ワーキングセット）の大きさに応じて決定する<strong>ワーキングセット法</strong>がある。</p>
<p>5.ワーキングセットを下回るメモリ量しかプロセスが確保できない場合，常時ページフォルトが発生し，CPUの実効効率を低下させる<strong>スラッシング</strong>が発生する。</p>
<p>12.2)ワーキングセットを求めるのは事実上不能な理由を示すとともに、動的ページ置き換えにおけるページフォールト平均間隔＋LRU法について、ワーキングセットを求めずにどのように実現したかを中心に説明しなさい。<br>
ワーキングセットは常時に命令フェッチ、デコード、命令実効のサイクルで変わるため，求めるのは事実上不可能である。そこで，ワーキングセット法を近似するために，ページフォルト発生の平均間隔を計算し，この情報を静的置換えアルゴリズムに加えて，動的にプロセスに与えるページフレーム数を変えるのは，ページフォルト平均間隔+LRU法である。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ー仮想記憶]]></title>
        <id>https://zy080080.github.io/post/D3L-F6vjm/</id>
        <link href="https://zy080080.github.io/post/D3L-F6vjm/">
        </link>
        <updated>2021-01-18T16:06:45.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第11章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第11章　まとめ</p>
<!-- more -->
<p>仮想記憶</p>
<ul>
<li>大きさが無限の仮想アドレスを提供</li>
<li>ただし，スワップ操作に膨大な時間を要する</li>
</ul>
<p><strong>デマンドページング</strong>：</p>
<ul>
<li>ページフォルトが発生した時点</li>
<li>必要になった際に必要なページをスワップイン</li>
<li>スワップインの前にページフォルトが必ず発生</li>
<li><strong>ページフォルト処理にかかるコスト</strong>を削減したい</li>
</ul>
<p><strong>プリページング</strong>（予測ページング）</p>
<ul>
<li>必要になりそうなページを前もってスワップイン</li>
<li>予測が当たればページフォルトは発生せず<strong>コスト削減</strong></li>
</ul>
<p>デマンドプリフェッチ：</p>
<ul>
<li>ページフォルト割り込みが発生したタイミングで
<ul>
<li>ページフォルトを起こした対象ページは無論スワップイン</li>
<li><strong>将来必要と予想される数ページを同時に</strong>スワップイン</li>
</ul>
</li>
</ul>
<hr>
<p>1.仮想記憶の性能を向上させるためには，できる限りスワップ操作を行わないことが重要である。したがって，ページフォルト時にどのページをスワップアウトするかを決定するスワップスケジューリングは重要である。</p>
<p>2.スワップ操作は最小限にするべきであり，あらかじめ必要とされるページを事前にスワップインする方式として，<strong>デマンドプリフェッチ</strong>，<strong>初期ロードプリフェッチ</strong>などがある。</p>
<p>3.もっともアクセスされていないページをスワップアウトの対象とする<strong>LRUアルゴリズム</strong>は，今後アクセスされる確率のもっとも少ないページを近似的に選択可能なアルゴリズムである。しかし，このLEUアルゴリズムを正確に実装することも困難であり，経験的手法による近似的な実装が必要となる。</p>
<p>4.LRUアルゴリズムを近似的に実装するために，ページテーブル内に前回のページフォルト以降，当該ページの参照の有無を示す参照ビットを追加する。次のページフォルト時点で，参照頻度表を更新することにより，近似的，かつ少ない不可でLRUアルゴリズムを実装することが可能となる。</p>
<p>5.プログラムのアクセスする主記憶領域には，時間的および空間的局所性がある。さらに，プログラムが関数や手続きを高級言語で記述した場合は，関数や手続きの呼び出し時点で，急激にアクセスするページが変化する<strong>フェーズ現象</strong>が発生する。</p>
<p>(11-1)正確なLRUはなぜ実装困難なのかを、具体的な操作、および数字を示して説明しなさい。<br>
LRUを実現するには，ページテーブルに，各ページのアクセス時刻を記録する項目を追加する必要がある。具体的には，主記憶アクセスごとに時刻を調べてアクセス時刻を更新し，ページフォルト時にページテーブルを走査して，最もアクセス時刻の古い項目を探す必要がある。<br>
しかし，主記憶アクセスは10の-9乗秒程度の速度を要求され，時刻を更新するのに10の-9乗秒でできないため，LRUは実装困難である。</p>
<p>(11-2)高級言語によるプログラムの主記憶アクセスパターンのフェーズ化が、どのような時点で、なぜ起こるかを、２つ事例を示して、説明しなさい。<br>
フェーズ化は，プログラムがアクセスするページは主記憶上隣接した領域を連続してアクセスする時，及びある時刻を境にプログラムがアクセスするページが急に切り替わる時に起こる。<br>
事例：1.ループを抜けた時。2.実行する関数が変わった時。<br>
その理由は，プログラムが頻繁にアクセスするページ，またはその近くのアドレスに再びアクセスしなくなるからである。</p>
<p>(11-3)スワップインすべき場所の選択に意味がないことを示しなさい。<br>
ページシステムの特徴に，ページテーブルを介して，ページとページフレームをマッピンッグすることによるページフレームの動的再配置機能がある。よって，スワップイン操作により，該当ページが主記憶上のどのページフレームに読み込まれてもシステムの性能やプロフラム側が発行するアドレスに全く影響しない。<br>
　通常のメモリアクセスは10<sup>(-9)秒程度の速度を要求されるが，スワップ操作時は10</sup>(-1)秒程度の時間を要求されるだけである。したがった，スワップ操作時にさらに10<sup>(-3)〜10</sup>(-2)秒程度の追加の処理を挿入しても，ほとんどシステム全体の性能に影響することはない。</p>
<p>ページングによるメモリ管理は，アドレスの上位を（ページ番号），下位を（オフセット）に分けて管理する方式である。（ページ番号）は（ページテーブル）内の位置を示し，示された（ページテーブル）のエントリーには各種フラグと（ページフレーム番号）を示すポインタが格納されている。仮想記憶におけるページ置き換えをページフォルト時に行う方式を（デマンドページング）と呼ぶ。さらに，ページフォルトが起こった時に，そのページだけではなく，将来必要となるページも呼び込む方式が（<strong>デマンドプリフェッチ</strong>）である。理想的なページ置き換えは，次にアクセスされる確率のもっとも（低い）ページを置き換え（スワップアウトする）方法である。この近似解として（LRU）がある。しかし，（LRU）も正確に実装することが困難なので，さらに近似が必要となる。<br>
　プログラムが使用するページの集合は，プログラムの実行にしたがって急激に変化することが多い，これを（フェーズ化）現象と呼び，一般に関数などにより，プログラムを（<strong>構造化</strong>）した場合に顕著となる</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ーセグメンテーション，ページかセグメンテーション]]></title>
        <id>https://zy080080.github.io/post/zAjTn6PkI/</id>
        <link href="https://zy080080.github.io/post/zAjTn6PkI/">
        </link>
        <updated>2021-01-18T11:35:35.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第10章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第10章　まとめ</p>
<!-- more -->
<p><strong>多重レベルページング</strong>：</p>
<ul>
<li>従来のページングにおける，仮想アドレスの「ページ番号部」を複数に分割</li>
<li>それぞれをページ番号として階層化したテーブルを検索</li>
<li>必要なテーブルのみを主記憶上に置くことで，主記憶使用量を削減（残りは仮想記憶へ）</li>
<li>ただし，多段化により，主記憶アクセスは増加 =&gt;TLBにより解決</li>
</ul>
<p><strong>0レベルページング（連想写像方式）</strong>：</p>
<ul>
<li>一般的なページング
<ul>
<li>主記憶上にページテーブル</li>
<li>CPU内のMMUが，ページテーブルを用いてアドレス変換</li>
</ul>
</li>
<li>0レベルページング
<ul>
<li>ハードウェアとしてのMMUを持たない</li>
<li>一般的なページテーブルを持たず，連想メモリで構成したTLBでアドレス変換</li>
</ul>
</li>
<li>メリット
<ul>
<li><strong>高クロック</strong>実装が可能
<ul>
<li>MMU不要のため，CPU機構が単純化</li>
</ul>
</li>
</ul>
</li>
<li>デメリット
<ul>
<li>TLBヒットしなかった場合のオーバーヘッドが膨大
<ul>
<li>ソフトウェア処理のため</li>
</ul>
</li>
</ul>
</li>
<li>よって
<ul>
<li>主記憶使用量の少ないプログラムには<strong>高速</strong></li>
<li>主記憶使用量の多いプログラムには<strong>非常に低速</strong></li>
</ul>
</li>
</ul>
<p><strong>セグメンテーション</strong>：</p>
<p>ページングの上，プログラム部，データ部，スタック部などの分離とプロセス間で共有を実現する。</p>
<ul>
<li>ページ（ページング）
<ul>
<li>一定の大きさを割り当て単位とする</li>
</ul>
</li>
<li>セグメント（セグメンテーション）
<ul>
<li>プロセスに対し<strong>複数</strong>のセグメントを割り当て
<ul>
<li>各セグメントは論理的に<strong>独立</strong></li>
<li>プログラム部，データ部など固有領域として使用可能</li>
</ul>
</li>
<li>各セグメントはその論理区間の大きさを自由に<strong>増減可能</strong></li>
</ul>
</li>
<li>利点
<ul>
<li>プログラム部，データ部など，用途別に複数をプロセスに割り当て</li>
<li>各セグメンテーションは大きさを増減可能</li>
</ul>
</li>
<li>欠点
<ul>
<li>フラグメンテーション</li>
</ul>
</li>
</ul>
<p><strong>ページ化セグメンテーション</strong>：</p>
<ul>
<li>セグメンテーションを複数のページにより構成する。</li>
<li>セグメントごとにページテーブルを用意</li>
<li>利点：
<ul>
<li>フラグメンテーションの回避
<ul>
<li>主記憶割り当ては基本的にページ単位</li>
</ul>
</li>
<li>複数セグメント
<ul>
<li>各セグメントは大きさ増減可能</li>
<li>複数使用により，用途別に使い分け可能</li>
</ul>
</li>
<li>プロセス間共有
<ul>
<li>セグメンテーションとほぼ同様に共有可能<br>
　- ページテーブルの分散</li>
<li>ページテーブルが複数に分割されるので，多重レベルページング同様，その一部を<strong>仮想記憶に追い出すことで主記憶使用量削減</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="ポイント">ポイント</h2>
<p>1.高級言語では，プログラム領域，データ領域，スタック領域，動的データ領域など複数のアドレス空間を用いる。<strong>セグメンテーション</strong>を用いることにより，プログラムに対して複数の異なるアドレス空間を提供することが可能である。さらに，複数のプロセス間で仮想アドレス空間を共有する共有メモリも容易に実現可能である。</p>
<p>2.<strong>ページカセングメンテーション</strong>は，ページングとセグメンテーションの両方の利点を有する方式であり，現在の主記憶管理手法の主流である。</p>
<p>3.ページングシステムでは，ページテーブルの大きさが大きくなり，主記憶領域を圧迫する。しかし，<strong>ページかセグメンテーション</strong>や<strong>多重レベルページング</strong>などでは，ページテーブルも仮想記憶内で管理するため，解決可能である。</p>
<p>4.最小限のハードウェアで高性能を得るために開発され，MIPS社のR2000で採用された0レベルページングは，ページテーブルの管理を，ハードウェアで実装されたMMUではなく，ソフトウェア割り込みで実装した。</p>
<p>10.1　多重レベルページングと仮想記憶を用いることにより，主記憶内に存在するページテーブルの大きさが無視できることを示せ。<br>
　多重レベルページングを用いることにより，各プロセスが必要とするページテーブル自体も仮想記憶の対象となる。つまり，全てのページテーブルのうち，直近にアクセスされたページテーブルの一部のみが主記憶に存在することになる。したがって，プロセスが現時点で必要としているページテーブル部分のみが主記憶に配置される。</p>
<p>10.2　ページ化セグメンテーションにおいて，外部・内部フラグメンテーションの問題について説明せよ。<br>
　ページ化セグメンテーションは主記憶の割り当てはページ単位の固定長割り当てなので，外部セグメンテーションは存在しない。しかし，プロセスには主記憶をページ単位で割り当てるため，例えばページサイズが8kBの場合，複数割り当てたページ群の最後のページで平均4KBの未使用領域（内部フラグメンテーション）が発生する。しかし，現在のプロセスに必要な主記憶量に比べると無視できる量である。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ーページング]]></title>
        <id>https://zy080080.github.io/post/M7ToAnBlI/</id>
        <link href="https://zy080080.github.io/post/M7ToAnBlI/">
        </link>
        <updated>2021-01-18T06:23:01.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第9章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第9章　まとめ</p>
<!-- more -->
<p><strong>仮想記憶</strong>：主記憶の動的再配置により，プロセスが使用できる主記憶領域を無限大にする方式。</p>
<p><strong>仮想アドレス</strong>：記憶容量に制限のない論理アドレス。</p>
<p><strong>スワップイン</strong>：</p>
<ul>
<li>実行中のプログラムが必要となる領域を二次記憶から主記憶に転送する操作。</li>
</ul>
<p><strong>スワップアウト</strong>：</p>
<ul>
<li>スワップインを行う際，その空き領域を確保するために，当面必要としない領域を主記憶から二次記憶に転送する操作。</li>
</ul>
<p>記憶領域の仮想化</p>
<ul>
<li>仮想アドレス空間の一部が物理メモリに存在</li>
<li>仮想アドレスと物理アドレスの対応付けが必要</li>
<li>物理メモリ上に存在する「仮想記憶の一部」は時々刻々変化する（<strong>動的再配置</strong>）</li>
<li>対応付けも時々刻々へ変化</li>
</ul>
<p><strong>ページング</strong>：ロック/キー機構に動的再配置機能を加えた方式である。</p>
<p><strong>ページ</strong>：<strong>仮想アドレス</strong>を上位部と下位部に分割することによって生成されたブロック単位。</p>
<p><strong>ページフレーム</strong>：<strong>物理アドレス</strong>を上位部と下位部に分割することによって生成されたブロック単位。</p>
<p><strong>ページテーブル</strong>：ページ番号からページフレーム番号へのマッピングを行うテーブル。</p>
<p>仮想アドレスは通常プロセスごとに独立して存在する多重仮想記憶として実装される。したがって，ページテーブルもプロセスごとに複数必要となり，書くプロセスのPSW情報中に，主記憶中のどこに自プロセスのページテーブルが格納されているかを示すポインタ情報を格納する<strong>ページテーブルレジスタ</strong>がある。</p>
<p>フラグ</p>
<ul>
<li><strong>Vフラグ</strong>（Virtual Memory Flag）
<ul>
<li>そのページが主記憶に存在するか否かを示す</li>
<li>1の場合はスワップインが必要</li>
</ul>
</li>
<li><strong>Pフラグ</strong>（Permission Flag）
<ul>
<li>そのページに対するアクセス条件を表す</li>
<li>例：001（読み込み可）010（書き込み可）100（実行可）</li>
</ul>
</li>
<li><strong>Cフラグ</strong>（Change Flag）
<ul>
<li>スワップイン後，そのフレームに対して書き込みが行われたか（変更されたか）否かを表す</li>
<li>1の場合は，スワップアウト時に二次記憶へのフレームの書き戻しが必要</li>
</ul>
</li>
</ul>
<p>プロセスはページ単位でしかメモリ量を要求でいないため，メモリフラグメンテーションの問題は発生しない。<br>
<strong>内部フラグメンテーション</strong>：割り当てられたが，使用されない領域。</p>
<ul>
<li>一ページが4~8kB程度なので，主記憶の全容量からすると微々たる大きさ，ほとんど無視できる。</li>
</ul>
<p><strong>ページングの問題点</strong>：</p>
<ul>
<li>ページテーブルの巨大さ
<ul>
<li>例）仮想アドレス32bit，1ページ8kBの場合
<ul>
<li>ページエントリ数：50万</li>
</ul>
</li>
<li>ページテーブルはプロセス毎に独立
<ul>
<li>例）100プロセスの場合のエントリ数：5000万，1エントリ10Bで構成すると500MB</li>
</ul>
</li>
<li>解決法：
<ul>
<li>ハッシュ関数によるページテーブル</li>
</ul>
</li>
</ul>
</li>
<li>メモリアクセスの増大
<ul>
<li>ページテーブルは主記憶内に存在</li>
<li>1回で２度の主記憶アクセスが必要
<ul>
<li>ページテーブルへのアクセス</li>
<li>物理アドレスへのアクセス</li>
</ul>
</li>
<li>解決法：
<ul>
<li>連想レジスタ方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>連想レジスタ</strong>（TLB：Translation Lookaside Buffer）：</p>
<ul>
<li>最近行われた変換結果をCPU内で保持</li>
<li>小容量で高速</li>
<li>一般的にプログラムは，「<strong>一度アクセスしたアドレスを近いうちに再度アクセスする可能性が高い</strong>」ことを利用</li>
</ul>
<p>アクセス速度の違い</p>
<ul>
<li>CPU基本サイクル   約10^(-9)秒</li>
<li>CPUが主記憶へアクセスする速度 約10^(-7)秒</li>
<li>スワップイン・スワップアウトで二次記憶へアクセス速度  約10^(-3)秒</li>
</ul>
<hr>
<p>1.主記憶の再配置機能を持つ<strong>ページング</strong>は，現在用いられている主記憶管理の基本である。仮想アドレスの上位をページ番号部，下部をオフセット部とし，ページ番号部は，ページテーブルを参照して，物理アドレスであるページフレーム番号に変換される。また，ページテーブルには各ページごとにアクセス制御グラフなどが配置され，ページのアクセス権を設定することができる。</p>
<p>2.ページングは，仮想記憶が実現できるとともに，メモリフラグメンテーション問題も解決可能である。しかし，ページテーブルを主記憶に配置する必要があるため，主記憶へのアクセス速度が低下する可能性がある。アクセス速度を低下させないために，<strong>TLB</strong>（<strong>連想レジスタ</strong>）を用いる。</p>
<p>3.ページテーブルを主記憶上に全て配置した場合，その大きさが無視できなくなる。主記憶上のページテーブルを削減するとして，ハッシュ関数を用いて，現在主記憶上にあるページフレームを管理するページテーブルのみを主記憶上に配置する方式がある。</p>
<p>4.仮想記憶の利用を前提とした場合，主記憶のアクセス速度と，２次記憶のアクセス速度に注意する必要がある。両者のアクセス速度は数万倍の差があり，過度な仮想記憶の利用はできる限り避けるべき。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理ー主記憶割り当て]]></title>
        <id>https://zy080080.github.io/post/ES4qIO3DM/</id>
        <link href="https://zy080080.github.io/post/ES4qIO3DM/">
        </link>
        <updated>2021-01-17T15:41:41.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第8章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第8章　まとめ</p>
<!-- more -->
<p>領域要求のタイミング：</p>
<ul>
<li>静的（static）要求
<ul>
<li>プログラム実行開始時に必要領域を要求</li>
</ul>
</li>
<li>動的（dynamic）要求
<ul>
<li>プログラム実行開始時に最低限の領域を要求</li>
<li>実行につれてさらに必要となった場合はその都度要求</li>
</ul>
</li>
</ul>
<p><strong>固定区画方式</strong>：</p>
<ul>
<li>プロセスに割り当てる領域の大きさをあらかじめ決めておく</li>
<li>プロセスから要求があった際，その決められた大きさの領域を割り当てる</li>
<li>特徴：
<ul>
<li>新しいプロセスの生成時に，領域を割り当てるコストが非常に少ない（選択の幅がない）</li>
</ul>
</li>
<li>欠点：
<ul>
<li>小規模の主記憶領域しか必要としないプロセスにとっては，利用しない領域まで割り当ての対象となり，結果としてOS全体で考えた場合の主記憶領域の使用効率が低下する。</li>
</ul>
</li>
</ul>
<p><strong>可変区画方式</strong>：</p>
<ul>
<li>プロセスは，必要な分だけ領域を要求</li>
<li>プロセスごとに要求サイズは異なる</li>
<li>要求があった分だけ割り当てる</li>
<li>問題点
<ul>
<li>空き領域の検索コスト
<ul>
<li>処理が進行するに従い，様々な大きさの空き領域が発生</li>
<li>新しいプロセスの要求に合う大きさの空き領域を探すコストが増大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>断片化（フラグメンテーション）</strong>：</p>
<ul>
<li>プロセスからの要求サイズは異なるため，可変区画方式で眼持ちを割り当てると，プロセスが使えない大量の小さな領域が残ってしまう現象。</li>
<li>解決法：<strong>メモリコンパクション</strong>
<ul>
<li>メモリを確保しているプロセスの実行を止めた後に，断片化した領域を１つの連続した領域にまとめる。</li>
</ul>
</li>
</ul>
<p>可変区画方式における空き領域管理：</p>
<ul>
<li><strong>ベストフィット方式</strong>
<ul>
<li>割り当てた残り領域がもっとも少なくなる空き領域に割り当てる方式</li>
<li>一番効率的に見えるが</li>
<li>欠点
<ul>
<li>空き容量の探索コストが大きくなる場合がある</li>
<li>残った領域が小さすぎて他のプロセスが使用できない確率が高い</li>
</ul>
</li>
</ul>
</li>
<li><strong>ワーストフィット方式</strong>
<ul>
<li>割り当てた残り領域がもっとも大きくなる空き領域に割り当てる方式</li>
<li>残った領域は，ベストフィット方式より比較的大きくなる</li>
<li>欠点
<ul>
<li>処理が進むにつれ空き領域の大きさが均一化し，大きい要求に応じられない</li>
</ul>
</li>
</ul>
</li>
<li><strong>ファーストフィット方式</strong>
<ul>
<li>要求された量を確保できる最初に見つかった領域を割り当てる方式</li>
<li>探索コストが小さい。主記憶領域の全てを調べる必要がない</li>
<li>アドレス上位に大きい領域が残りやすくなり，大きい要求にも対応しやすい</li>
</ul>
</li>
</ul>
<h2 id="領域管理">領域管理</h2>
<h3 id="リスト方式">リスト方式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">アドレス：A1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">サイズ：S1</td>
</tr>
<tr>
<td style="text-align:center">next</td>
</tr>
</tbody>
</table>
<p>アドレス順リストの場合：ファーストフィット方式での検索が高速。<br>
大きさ順リストの場合：ベストフィット方式での検索が高速。</p>
<h3 id="ビットマップ方式">ビットマップ方式</h3>
<p>空き情報を示す配列</p>
<ul>
<li>ビットマップ
<ul>
<li>記憶領域を単位ブロックに分割
<ul>
<li>例：アドレスの上位数ビットが共通の部分など</li>
</ul>
</li>
<li>各領域に対応するビットを用意</li>
</ul>
</li>
<li>ビット配列により，主記憶全体の空き領域を表現
<ul>
<li>大きい連続した空き領域を検索する際は
<ul>
<li>フラグに０が続いている部分を探索</li>
</ul>
</li>
<li>各要素へのアクセスは高速だが，<strong>空き領域の検索コストが大きくなりがち</strong></li>
</ul>
</li>
</ul>
<h2 id="プログラムのロードと領域の再配置">プログラムのロードと領域の再配置</h2>
<p>プログラム記述から実行までの流れ：<br>
通常はリンケージエディタにおいてユーザがプログラム中に使ったライブラリ関数を結合し，即時実行可能形式（<strong>ロードモジュール</strong>）として，ファイルに格納されるとともに，実行時にはこのイメージのまま主記憶にロードされる。</p>
<p><strong>静的ライブラリ</strong></p>
<ul>
<li>リンク時にロードモジュールに<strong>埋め込み</strong>（静的リンク）</li>
<li>複数プログラムで使用されるライブラリがある場合，主記憶領域の無駄</li>
</ul>
<p><strong>共有ライブラリ</strong>：</p>
<ul>
<li>主記憶内にロードされた複数のプログラムから共有可能なライブラリ。</li>
<li>リンカはロードモジュールにライブラリの埋め込みを行わない。</li>
<li>共有ライブラリに対するリンク情報のみロードモジュールに書き込む</li>
<li>ロードモジュールは<strong>リンク情報のみ</strong>を持ち，<strong>実行時にリンク</strong>（ダイナミックリンク）</li>
<li>複数プログラムで使用される場合でも，各ライブラリは１つのイメージだけ主記憶上に存在すればよい</li>
<li>主記憶領域（およびディスク領域）の有効活用</li>
<li>共有ライブラリが<strong>リエントラント</strong>である</li>
</ul>
<p><strong>リエントラント性</strong></p>
<ul>
<li>複数のプログラム間で同一関数を共有するには，あるプログラムがその関数を実行中に中断された後，他のプログラムが同一関数を実行した後であっても，中断直後の状態から同一関すを再開できる必要がある。</li>
<li>複数のプログラムが主記憶上にロードされた変数を同時に利用可能な性質を<strong>リエントラント性</strong>(再入可能性)と呼ぶ。</li>
<li>各呼び出しごとに，作業領域を保存する仕組みが必要
<ul>
<li>関数内でグローバル偏すをアクセスしない。関数内でstaticな変数を使わないなど。</li>
</ul>
</li>
</ul>
<p><strong>実行時結合</strong>：実行時にリンク操作を行う</p>
<p><strong>リロケータブル（再配置可能）</strong>：プログラム本体が，主記憶上の任意の位置に配置（ロード）されても実行可能である性質。</p>
<ul>
<li>この場合，プログラム内の全てのアドレス指定が，プログラムの先頭のアドレスからの相対位置で表現されている必要がある。</li>
</ul>
<p><strong>共有ライブラリの現状</strong></p>
<ul>
<li>共有ライブラリは，主記憶の効率的利用という観点からは望ましい</li>
<li>しかし，プログラム（ライブラリ）全てがリエントラント性を満たすためには相当な書き換えが必要。</li>
<li>現状
<ul>
<li>ダイナミックリンク（単体）は，利用されている
<ul>
<li>２次記憶の有効利用</li>
<li>脆弱性対応時の容易性 =&gt;ライブラリだけを配布すれば良い（例　Windows　DLL）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="オーバーレイ">オーバーレイ</h2>
<p>オーバーレイ</p>
<ul>
<li>指定した時刻に，アプリケーションのどの部分が主記憶上に存在すべきかをプログラマが指定する仕組み</li>
<li>毎に実行されたコード（親関数など）のうち，さしあたり(目前)必要のなくなったコードがロードされている主記憶領域に対して，新しく必要となったコードを上書き（overlay）できる</li>
<li>欠点
<ul>
<li>非常に複雑でエラーを起こしやすい</li>
<li>プログラマの負担が増大</li>
</ul>
</li>
</ul>
<p>軽量に仮想記憶を実装できるオーバーレイはIoTなどの分野で今後も重要な位置を占める</p>
<hr>
<p>1.マルチプログラミング環境では，プログラムの発生，消滅が頻繁に起こるため，プログラム（およびデータ）を格納する領域を管理する方式が重要となる。</p>
<p>2.メモリの割り当て方式には，あらかじめ決められたシステムで決めた大きさの領域を全てのプロセスに平等に割り当てる<strong>固定区画方式</strong>と，プロセスが要求する大きさの領域を与える可変区画方式がある。</p>
<p>3.可変区画方式において，もし適切な管理を行わないと，プロセスが使えない断片的なメモリ領域が数多く発生する<strong>メモリフラグメンテーション</strong>が起こる。</p>
<p>4.空き領域を管理する方法として，リストデータ構造を用いるリスト方式と，配列を用いる<strong>ビットマップ方式</strong>がある。また，割り当て方式として，<strong>ベストフィット方式</strong>，<strong>ファーストフィット方式</strong>，<strong>ワーストフィット方式</strong>がある。</p>
<p>5.マルチプログラミング環境では，主記憶を効率よく利用するために，複数のプログラムが，主記憶中にロードされたライブラリを共有できる<strong>共有ライブラリ</strong>が有効な手法である。共有ライブラリを実現するためには，プログラムのリエントラント性，およびプログラムの実行時にライブラリを結合する<strong>ダイナミックリンク</strong>が必要である。</p>
<p>6.プログラマが明示的にプログラムの主記憶へのロードを管理し，現在実行している部分のみを主記憶にロードすることにより，プログラムの実行に必要な主記憶量を提言する方法を<strong>オーバーレイ</strong>と呼ぶ。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：主記憶管理基礎]]></title>
        <id>https://zy080080.github.io/post/u3Uh6KrGp/</id>
        <link href="https://zy080080.github.io/post/u3Uh6KrGp/">
        </link>
        <updated>2021-01-17T09:24:20.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第7章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第7章　まとめ</p>
<!-- more -->
<p><strong>物理アドレス空間</strong>：主記憶上の実アドレス空間。</p>
<p><strong>論理アドレス空間</strong>：プログラムからみた，各プロセスごとに独立した実アドレス空間に対応するアドレス空間。</p>
<p><strong>主記憶管理部</strong>(memory management unit：<strong>MMU</strong>)：各プロセスごとの論理アドレス空間を一次元アドレスで表現されている受寄屋上の物理アドレス空間へ変換（Mapping）を行うハードウェアである。</p>
<p><strong>ネーミング関数</strong>：</p>
<ul>
<li>変数，定数などの識別子を論理アドレスに変換する関数</li>
<li>コンパイル・リンク時に行われる</li>
</ul>
<p><strong>メモリ関数</strong>：</p>
<ul>
<li>論理アドレスから物理アドレスに変換する関数。</li>
<li>OSによって行われる</li>
</ul>
<p><strong>内容関数</strong>：</p>
<ul>
<li>物理アドレスから，そのアドレスに格納された内容に変換する関数</li>
<li>ハードウェアによって行われる</li>
</ul>
<p><strong>下限レジスタ</strong>：主記憶上のOS領域とユーザ領域の境界を示すレジスタである。</p>
<p>下限レジスタ機構とその問題点：</p>
<ul>
<li>ユーザ領域の下限を設定
<ul>
<li>下限レジスタが示す境界でOS/ユーザ領域を区別</li>
</ul>
</li>
<li>問題点
<ul>
<li>領域境界が１つしかない</li>
<li>OS領域を保護することしかできない</li>
<li>複数のプロセス間でアクセス権は設定できない</li>
</ul>
</li>
</ul>
<p>そのため，任意・複数の境界を設定し，プロセスごとにアクセス権を設定したい。 -&gt;ロック/キー機構</p>
<hr>
<p>1.<strong>主記憶管理</strong>の目的は，ユーザに独立した仮想アドレス空間を提供することである。理想的な仮想アドレス空間を持つべき特徴としては，大きさ無制限，プロセスごとに固有，プロセス間で主記憶空間を共有可，プログラム部，データ部，スタック部など複数の１次元アドレスがある。</p>
<p>2.<strong>下限レジスタ機構</strong>は，ユーザ領域とオペレーティングシステム領域を下限レジスタが示す位置で分離し，CPUの実行モードにより，オペレーティングシステム領域へのアクセスを制限する基本的な仕組みである。</p>
<p>3.<strong>ロック/キー機構</strong>は，アドレスを論理的に上位と下位に分け，上位部の内容を主記憶を示すアドレスとしてだけでなく，主記憶ブロックへのアクセス権が格納されているロックデータ配列への添字（ポインタ情報）として用いる。この考え方は，ページング，セグメンテーションによるメモリ管理の基礎である。<br>
　現在実行中のプロセスの主記憶に対するアクセス権がPSWに格納されていて，それをキー部に対応するロックデータと比較して，アクセスを許可するかどうかを決める。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：並行プロセス-モニタ]]></title>
        <id>https://zy080080.github.io/post/ECsYYoE6u/</id>
        <link href="https://zy080080.github.io/post/ECsYYoE6u/">
        </link>
        <updated>2021-01-16T12:08:05.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第6章 まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第6章 まとめ</p>
<!-- more -->
<p>モニタとセマフォ</p>
<table>
<thead>
<tr>
<th style="text-align:center">セマフォ</th>
<th style="text-align:center">モニタ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P命令</br>共有リソースの取得トライ。失敗時に待ち行列へ</td>
<td style="text-align:center">wait()</br>待ち行列へ</td>
</tr>
<tr>
<td style="text-align:center">V命令</br>共有リソース返却，待ちプロセスを１つ実行可能状態へ</td>
<td style="text-align:center">signal()（Javaではnotify()）</br>待ちプロセスを１つ実行可能状態へ</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">queue()</br>待ちプロセスの有無を返す</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">セマフォ</th>
<th style="text-align:center">モニタ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P命令を実行しないとセマフォの状態がわからない</td>
<td style="text-align:center">メソッドにより，共有リソースの状態を排他的に調べられる</td>
</tr>
<tr>
<td style="text-align:center">リソースを取ろうとしないと，空いているかどうか不明</td>
<td style="text-align:center">リソースの空きの確認とリソース待ちが分離</td>
</tr>
<tr>
<td style="text-align:center">取れなかったら，いきなり待ち行列に待たされる</td>
<td style="text-align:center">条件変数へのwaitにより，自由度の高い「待ち」が可能</td>
</tr>
</tbody>
</table>
<p><strong>モニタの利点（セマフォに対し）</strong>：</p>
<ul>
<li>リソース確認と「待ち」状態の分離
<ul>
<li>リソースに空きがない場合，「待ち」に入るかどうか自由に選べる</li>
</ul>
</li>
<li>排他制御すべきリソースの明示
<ul>
<li>モニタ内に記述されるため明示的</li>
<li>他の一般的な変数と判別しやすい</li>
<li>排他的メソッドを通じた処置により保護</li>
</ul>
</li>
<li>プログラマに安全で扱いやすい枠組みを提供</li>
</ul>
<hr>
<p>1.<strong>モニタ</strong>とは，オブジェクト思考の考え方を排他制御（およびプロセス同期）に適用した解法である。モニタ内には，排他制御の対象となる<strong>リソース</strong>，リソースを操作するための<strong>メソッド</strong>，オブジェクトの実体を生成する際に実行する<strong>初期コード</strong>，<strong>終了時コード</strong>が存在する。</p>
<p>2.モニタ内のリソースは，メソッドを介してのみアクセス可能である。また，各モニタのメソッドは排他的に実行される。したがって，プログラマはモニタ内のリソースの排他制御を考慮する必要はない。</p>
<p>3.モニタを用いることにより，セマフォよりもさらに抽象度が高くできるとともに，デッドロックの可能性のある処理を，コンパイラで実行前にある程度事前に検出することも可能となる。</p>
<p>複数のプロセスが，同時に実行されている場合，共通のリソース（共有変数など）にアクセスする場合は（排他制御）が必要となる。また，（排他制御）が必要となる領域のことを（クリティカルセクション）と呼ぶ。（排他制御）の解決方法の代表的な例は（セマフォ）である。これは，待ち行列と整数変数を持つデータ構造であり，（P）命令と（V）命令により制御する。一般的には，（クリティカルセクション）に入る前に（P）命令を，出る前に（V）命令を実行する。さらに，より抽象度の高い（排他制御）の方法として，（モニタ）がある。（モニタ）は，（排他制御）の対象となるリソースを（オブジェクト）指向の枠組みで抽象化したモデルである。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OS：並列プロセス-セマフォ]]></title>
        <id>https://zy080080.github.io/post/oEPtkexau/</id>
        <link href="https://zy080080.github.io/post/oEPtkexau/">
        </link>
        <updated>2021-01-16T04:50:30.000Z</updated>
        <summary type="html"><![CDATA[<p>教科書第5章　まとめ</p>
]]></summary>
        <content type="html"><![CDATA[<p>教科書第5章　まとめ</p>
<!-- more -->
<p><strong>semaphore　セマフォ</strong>：整数型の変数（セマフォ変数）と，待ち行列からなるデータ構造を有する構造体である。この構造体へは，P命令，V命令の２つの操作が許されている。</p>
<p><strong>P命令</strong>：リソースを要求し，許可されない場合は待ち状態へ移行。</p>
<ul>
<li>空きリソースを1つ使用</li>
<li>空きリソース数（セマフォ変数）をデクリメント</li>
<li>空きがない場合，プロセスを待ち状態に</li>
</ul>
<p><strong>V命令</strong>：リソースを解放し，待ちプロセスを実行可能状態へ移行。待ちプロセスがない場合，空きリソース数をインクリメント。</p>
<ul>
<li>空きリソースを1つ解放</li>
<li>待ちプロセスを1つ実行可能状態に</li>
<li>待ちプロセスがない場合，空きリソース数（セマフォ変数）をインクリメント</li>
</ul>
<p><strong>デッドロック</strong>：全てのプロセスが，あるリソースを確保するために，別のリソースを確保したママ解放を待っている状態となってしまい，これらのリソースに関連する全てのプロセスの実行が止まってしまう状態。</p>
<p><strong>ダイニングフィロソファの解法</strong>：</p>
<ul>
<li>解法1：フォーク一本一本ではなく，「フォーク全体を使う権利」をセマフォで管理
<ul>
<li>うまくいくが，同時に一人しか食事できない。</li>
<li>実際は二人同時に食事可能な場合があるはず</li>
<li>リソースが有効利用できていない</li>
</ul>
</li>
<li>解法2：１つのプロセスだけが逆順でフォークを要求
<ul>
<li>うまくいくが，哲学者4が特殊であるため，<strong>公平性</strong>を欠いている可能性がある</li>
</ul>
</li>
<li>解法3：少し我慢をする哲学者
<ul>
<li>右のフォークを確保後，左のフォークが確保できなければ，一旦右のフォークを解放して少し待つ</li>
<li>これにより，「全員右フォークを確保した状態」から抜け出せる</li>
<li>問題点：全員が同時に「右フォーク確保，右フォーク解放」を繰り返すと，デッドロック。</li>
</ul>
</li>
<li>解法4：不定時間だけ我慢をする哲学者
<ul>
<li>右のフォークを確保後，左のフォークが確保できなければ，一旦右のフォークを解放して少し待つ</li>
<li>待つ時間はランダムに決定する</li>
<li>これによって，全員が同時に「右のフォークを確保，右のフォークを解放」を繰り返すことがなくなる</li>
<li>問題点：デッドロックが発生しないことを証明できない。フォークを解放して「譲った」哲学者は，次に優先される仕組みがないと公平性に欠ける。</li>
</ul>
</li>
<li>理想的な解法：
<ul>
<li>リソース確保に失敗した場合，当該リソースを確保するための<strong>待ち行列に並ぶことができる</strong>こと</li>
<li>全てのプロセスがリソースを<strong>平等に確保できる</strong>ことを保証すること</li>
</ul>
</li>
</ul>
<hr>
<p>1.<strong>P命令</strong>(wait)と<strong>V命令</strong>(signal)からなる<strong>セマフォア</strong>は，より抽象的な排他制御の仕組みとして開発された。セマフォを獲得できないプロセスは，待ち状態に移行するため，ビジーウェイティングの問題はない。</p>
<p>2.プロセス間通信や計算機間の通信(Local Area Network, Internetwork)をモデル化した<strong>プロデュサ/コンシューマ問題</strong>や，データベースアクセス制御をモデル化した<strong>リーダタイム問題</strong>は，非同期問題の解法として重要な例題である。</p>
<p>3.<strong>食事をする哲学者問題</strong>は，複数リソースを獲得する際のデッドロックをモデル化している。複数リソースを獲得するプログラムを作成する場合，常にデッドロックを考慮する必要がある。</p>
]]></content>
    </entry>
</feed>